diff --git a/bluetooth.gni b/bluetooth.gni
index de4cccb..bbb8392 100644
--- a/bluetooth.gni
+++ b/bluetooth.gni
@@ -14,8 +14,8 @@
 declare_args() {
   bluetooth_service_a2dp_sink_feature = false
   bluetooth_service_a2dp_source_feature = true
-  bluetooth_service_avrcp_ct_feature = true
-  bluetooth_service_avrcp_tg_feature = false
+  bluetooth_service_avrcp_ct_feature = false
+  bluetooth_service_avrcp_tg_feature = true
 
   if ((defined(global_parts_info) &&
        !defined(global_parts_info.telephony_call_manager)) ||
diff --git a/bundle.json b/bundle.json
index ebd4e31..7cb525d 100644
--- a/bundle.json
+++ b/bundle.json
@@ -83,7 +83,8 @@
         "safwk",
         "common_event_service",
         "state_registry",
-        "c_utils"
+        "c_utils",
+        "image_framework"
       ],
       "third_party": [
         "googletest",
diff --git a/services/bluetooth/hardware/BUILD.gn b/services/bluetooth/hardware/BUILD.gn
index b56e1ed..a1f6ea6 100644
--- a/services/bluetooth/hardware/BUILD.gn
+++ b/services/bluetooth/hardware/BUILD.gn
@@ -12,6 +12,7 @@
 # limitations under the License.
 
 import("//build/ohos.gni")
+import("//drivers/hdf_core/adapter/uhdf2/uhdf.gni")
 
 SUBSYSTEM_DIR = "//foundation/communication"
 PART_DIR = "$SUBSYSTEM_DIR/bluetooth_service/services/bluetooth"
@@ -23,6 +24,7 @@ ohos_shared_library("bluetooth_hdi_adapter") {
   stack_protector_ret = true
   include_dirs = [
     "include",
+    "//third_party/bounds_checking_function/include",
     "$PART_DIR/common",
   ]
 
diff --git a/services/bluetooth/ipc/src/bluetooth_avrcp_tg_stub.cpp b/services/bluetooth/ipc/src/bluetooth_avrcp_tg_stub.cpp
index 6031224..10b33dd 100644
--- a/services/bluetooth/ipc/src/bluetooth_avrcp_tg_stub.cpp
+++ b/services/bluetooth/ipc/src/bluetooth_avrcp_tg_stub.cpp
@@ -347,13 +347,13 @@ ErrCode BluetoothAvrcpTgStub::SetDeviceAbsoluteVolumeInner(MessageParcel &data,
     HILOGI("enter");
     std::shared_ptr<BluetoothRawAddress> addr(data.ReadParcelable<BluetoothRawAddress>());
     if (!addr) {
-        return BT_ERROR_IPC_TRANS_FAILED;
+        return TRANSACTION_ERR;
     }
     int32_t volumeLevel = data.ReadInt32();
 
     int32_t result = SetDeviceAbsoluteVolume(*addr, volumeLevel);
     if (!reply.WriteInt32(result)) {
-        return BT_ERROR_IPC_TRANS_FAILED;
+        return TRANSACTION_ERR;
     }
     return NO_ERROR;
 }
@@ -362,12 +362,12 @@ ErrCode BluetoothAvrcpTgStub::SetDeviceAbsVolumeAbilityInner(MessageParcel &data
     HILOGI("enter");
     std::shared_ptr<BluetoothRawAddress> addr(data.ReadParcelable<BluetoothRawAddress>());
     if (!addr) {
-        return BT_ERROR_IPC_TRANS_FAILED;
+        return TRANSACTION_ERR;
     }
     int32_t ability = data.ReadInt32();
     int32_t result = SetDeviceAbsVolumeAbility(*addr, ability);
     if (!reply.WriteInt32(result)) {
-        return BT_ERROR_IPC_TRANS_FAILED;
+        return TRANSACTION_ERR;
     }
     return NO_ERROR;
 }
@@ -376,16 +376,16 @@ ErrCode BluetoothAvrcpTgStub::GetDeviceAbsVolumeAbilityInner(MessageParcel &data
     HILOGI("enter");
     std::shared_ptr<BluetoothRawAddress> addr(data.ReadParcelable<BluetoothRawAddress>());
     if (!addr) {
-        return BT_ERROR_IPC_TRANS_FAILED;
+        return TRANSACTION_ERR;
     }
     int32_t ability = 0;
     int32_t result = GetDeviceAbsVolumeAbility(*addr, ability);
     if (!reply.WriteInt32(result)) {
-        return BT_ERROR_IPC_TRANS_FAILED;
+        return TRANSACTION_ERR;
     }
 
     if (!reply.WriteInt32(ability)) {
-        return BT_ERROR_IPC_TRANS_FAILED;
+        return TRANSACTION_ERR;
     }
     return NO_ERROR;
 }
diff --git a/services/bluetooth/server/src/bluetooth_avrcp_tg_server.cpp b/services/bluetooth/server/src/bluetooth_avrcp_tg_server.cpp
index f16050e..004ae9d 100644
--- a/services/bluetooth/server/src/bluetooth_avrcp_tg_server.cpp
+++ b/services/bluetooth/server/src/bluetooth_avrcp_tg_server.cpp
@@ -16,13 +16,14 @@
 #include "bluetooth_def.h"
 #include "bluetooth_avrcp_tg_server.h"
 #include "bluetooth_log.h"
-#include "bluetooth_utils.h"
+#include "bluetooth_utils_server.h"
 #include "interface_adapter_manager.h"
 #include "interface_profile.h"
 #include "interface_profile_avrcp_tg.h"
 #include "interface_profile_manager.h"
 #include "remote_observer_list.h"
 #include "permission_utils.h"
+#include "bluetooth_errorcode.h"
 
 
 namespace OHOS {
@@ -129,7 +130,7 @@ public:
 
     void OnConnectionStateChanged(const RawAddress &rawAddr, int state)
     {
-        HILOGI("res: %{public}s, state: %{public}d.", GET_ENCRYPT_AVRCP_ADDR(rawAddr), state);
+        HILOGI("res: %{public}s, state: %{public}d.", GET_ENCRYPT_ADDR(rawAddr), state);
         std::lock_guard<std::mutex> lock(observerMutex_);
 
         observers_.ForEach([rawAddr, state](IBluetoothAvrcpTgObserver *observer) {
@@ -466,17 +467,17 @@ void BluetoothAvrcpTgServer::NotifyVolumeChanged(int32_t volume)
     pimpl->service_->NotifyVolumeChanged(static_cast<uint8_t>(volume));
     HILOGI("end.");
 }
-int32_t SetDeviceAbsoluteVolume(const BluetoothRawAddress &addr, int32_t volumeLevel)
+int32_t BluetoothAvrcpTgServer::SetDeviceAbsoluteVolume(const BluetoothRawAddress &addr, int32_t volumeLevel)
 {
     return BT_NO_ERROR;
 }
 
-int32_t SetDeviceAbsVolumeAbility(const BluetoothRawAddress &addr, int32_t ability)
+int32_t BluetoothAvrcpTgServer::SetDeviceAbsVolumeAbility(const BluetoothRawAddress &addr, int32_t ability)
 {
     return BT_NO_ERROR;
 }
 
-int32_t GetDeviceAbsVolumeAbility(const BluetoothRawAddress &addr, int32_t &ability)
+int32_t BluetoothAvrcpTgServer::GetDeviceAbsVolumeAbility(const BluetoothRawAddress &addr, int32_t &ability)
 {
     ability = DeviceAbsVolumeAbility::DEVICE_ABSVOL_UNSUPPORT;
     return BT_NO_ERROR;
diff --git a/services/bluetooth/service/BUILD.gn b/services/bluetooth/service/BUILD.gn
index f208038..8bc4ad5 100644
--- a/services/bluetooth/service/BUILD.gn
+++ b/services/bluetooth/service/BUILD.gn
@@ -19,7 +19,7 @@ PART_DIR = "$SUBSYSTEM_DIR/bluetooth_service/services/bluetooth"
 BT_SERVICE_DIR = "$PART_DIR/service"
 
 declare_args() {
-  bluetooth_service_avrcp_avsession = false
+  bluetooth_service_avrcp_avsession = true
 }
 
 ServiceBleScanFilter = [ "src/ble/ble_scan_filter/src/ble_scan_filter_lsf.cpp" ]
@@ -261,6 +261,7 @@ ohos_shared_library("btservice") {
       "src/avrcp_tg/avrcp_tg_sub_unit_info.cpp",
       "src/avrcp_tg/avrcp_tg_unit_info.cpp",
       "src/avrcp_tg/avrcp_tg_vendor.cpp",
+      "src/avrcp_tg/avrcp_tg_volume_interface.cpp",
     ]
   }
 
@@ -344,7 +345,10 @@ ohos_shared_library("btservice") {
     "bluetooth:btcommon",
     "c_utils:utils",
     "common_event_service:cesfwk_innerkits",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdf_utils",
     "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
     "hilog:libhilog",
     "hisysevent:libhisysevent",
     "ipc:ipc_core",
@@ -364,7 +368,7 @@ ohos_shared_library("btservice") {
       "ability_runtime:wantagent_innerkits",
       "av_session:avsession_client",
       "input:libmmi-client",
-      "multimedia_image_framework:image_native",
+      "image_framework:image_native",
     ]
   }
 
diff --git a/services/bluetooth/service/include/interface_adapter_classic.h b/services/bluetooth/service/include/interface_adapter_classic.h
index 0c6e2ac..6a8598e 100644
--- a/services/bluetooth/service/include/interface_adapter_classic.h
+++ b/services/bluetooth/service/include/interface_adapter_classic.h
@@ -358,6 +358,13 @@ public:
      * @since 6
      */
     virtual bool IsHfpCodSupported(const RawAddress &device) = 0;
+
+    virtual bool SetHidPnpInfo(const std::string &remoteAddr, int vendorId, int productId, int version) = 0;
+    virtual bool SetHidDescInfo(
+        const std::string &remoteAddr, int ctryCode, const std::vector<uint8_t> &descData, int descLength) = 0;
+    virtual void GetHidPnpInfo(const std::string &remoteAddr, int &vendorId, int &productId, int &version) = 0;
+    virtual void GetHidDescInfo(
+        const std::string &remoteAddr, int &ctryCode, std::vector<uint8_t> &descData, int &descLength) = 0;
 };
 }  // namespace bluetooth
 }  // namespace OHOS
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.cpp b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.cpp
index f3296f7..0ddbe85 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.cpp
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.cpp
@@ -330,34 +330,65 @@ void AvrcTgNotifyPacket::AssembleVolumeChanged(Packet *pkt)
 {
     HILOGI("enter");
 
-    auto buffer = BufferMalloc(AVRC_TG_VENDOR_PACKET_TYPE_SIZE + AVRC_TG_VENDOR_PARAMETER_LENGTH_SIZE +
-                               AVRC_TG_NOTIFY_EVENT_ID_SIZE + AVRC_TG_NOTIFY_EVENT_ID_VOLUME_SIZE);
-    if (buffer == nullptr) {
-        HILOGE("BufferMalloc fail");
-        return;
-    }
-    auto bufferPtr = static_cast<uint8_t *>(BufferPtr(buffer));
-    HILOGI("BufferMalloc: %{public}ju",
-        (AVRC_TG_VENDOR_PACKET_TYPE_SIZE + AVRC_TG_VENDOR_PARAMETER_LENGTH_SIZE + AVRC_TG_NOTIFY_EVENT_ID_SIZE +
-            AVRC_TG_NOTIFY_EVENT_ID_VOLUME_SIZE));
+    if(crCode_ != AVRC_TG_CMD_CODE_NOTIFY) {
+        auto buffer = BufferMalloc(AVRC_TG_VENDOR_PACKET_TYPE_SIZE + AVRC_TG_VENDOR_PARAMETER_LENGTH_SIZE +
+                                   AVRC_TG_NOTIFY_EVENT_ID_SIZE + AVRC_TG_NOTIFY_EVENT_ID_VOLUME_SIZE);
+        if (buffer == nullptr) {
+            HILOGE("BufferMalloc fail");
+            return;
+        }
+        auto bufferPtr = static_cast<uint8_t *>(BufferPtr(buffer));
+        HILOGI("BufferMalloc: %{public}ju",
+            (AVRC_TG_VENDOR_PACKET_TYPE_SIZE + AVRC_TG_VENDOR_PARAMETER_LENGTH_SIZE + AVRC_TG_NOTIFY_EVENT_ID_SIZE +
+                AVRC_TG_NOTIFY_EVENT_ID_VOLUME_SIZE));
 
-    uint16_t offset = 0x0000;
-    offset += PushOctets1((bufferPtr + offset), packetType_);
-    HILOGI("packetType_: %{public}x", packetType_);
+        uint16_t offset = 0x0000;
+        offset += PushOctets1((bufferPtr + offset), packetType_);
+        HILOGI("packetType_: %{public}x", packetType_);
 
-    parameterLength_ = AVRC_TG_NOTIFY_EVENT_ID_SIZE + AVRC_TG_NOTIFY_EVENT_ID_VOLUME_SIZE;
-    offset += PushOctets2((bufferPtr + offset), parameterLength_);
-    HILOGI("parameterLength_: %{public}d", parameterLength_);
+        parameterLength_ = AVRC_TG_NOTIFY_EVENT_ID_SIZE + AVRC_TG_NOTIFY_EVENT_ID_VOLUME_SIZE;
+        offset += PushOctets2((bufferPtr + offset), parameterLength_);
+        HILOGI("parameterLength_: %{public}d", parameterLength_);
 
-    offset += PushOctets1((bufferPtr + offset), eventId_);
-    HILOGI("eventId_: %{public}x", eventId_);
+        offset += PushOctets1((bufferPtr + offset), eventId_);
+        HILOGI("eventId_: %{public}x", eventId_);
 
-    PushOctets1((bufferPtr + offset), volume_);
-    HILOGI("volume_: %{public}x", volume_);
+        PushOctets1((bufferPtr + offset), volume_);
+        HILOGI("volume_: %{public}x", volume_);
 
-    PacketPayloadAddLast(pkt, buffer);
+        PacketPayloadAddLast(pkt, buffer);
 
-    BufferFree(buffer);
+        BufferFree(buffer);
+    } else {
+        // Packing  Register Volume_Changed Notification command
+        size_t bufferSize = AVRC_TG_VENDOR_PACKET_TYPE_SIZE + AVRC_TG_VENDOR_PARAMETER_LENGTH_SIZE +
+            AVRC_CT_NOTIFY_PARAMETER_LENGTH;
+        HILOGI("BufferMalloc: %{public}zu", bufferSize);
+
+        auto buffer = BufferMalloc(bufferSize);
+        if (buffer == nullptr) {
+            HILOGE("BufferMalloc fail");
+            return;
+        }
+        auto bufferPtr = static_cast<uint8_t *>(BufferPtr(buffer));
+
+        uint16_t offset = 0x0000;
+        offset += PushOctets1((bufferPtr + offset), packetType_);
+        HILOGI("packetType_: %{public}x", packetType_);
+
+        offset += PushOctets2((bufferPtr + offset), AVRC_CT_NOTIFY_PARAMETER_LENGTH);
+        HILOGI("parameterLength_: %{public}d", parameterLength_);
+
+        offset += PushOctets1((bufferPtr + offset), eventId_);
+        HILOGI("eventId_: %{public}x", eventId_);
+
+        PushOctets4((bufferPtr + offset), 0);
+        HILOGI("interval_: %{public}d", interval_);
+
+        PacketPayloadAddLast(pkt, buffer);
+
+        BufferFree(buffer);
+    }
 }
 
 void AvrcTgNotifyPacket::AssembleCommonChanged(Packet *pkt)
@@ -416,13 +447,19 @@ bool AvrcTgNotifyPacket::DisassembleParameters(uint8_t *buffer)
             AssembleRejectPacket();
             break;
         }
+        if(eventId_ == AVRC_TG_EVENT_ID_VOLUME_CHANGED) {
+            payload = 0x00;
+            PopOctets1((buffer + offset), payload);
+            volume_ = static_cast<uint8_t>(payload) & 0b01111111;
+            HILOGI("volume_: %{public}x", volume_);
+        }
 
         payload = 0x00;
         PopOctets4((buffer + offset), payload);
         interval_ = static_cast<uint32_t>(payload);
         HILOGI("interval_: %{public}u", interval_);
 
-        crCode_ = AVRC_TG_RSP_CODE_INTERIM;
+        // crCode_ = AVRC_TG_RSP_CODE_INTERIM;
 
         isValid_ = true;
 
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.h b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.h
index 89275dd..3e17607 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.h
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_notification.h
@@ -61,6 +61,7 @@ enum AvrcTgNotify {
     AVRC_TG_NOTIFY_EVENT_PLAYER_ID_SIZE = 0x02,           // The size of the "Player Id".
     AVRC_TG_NOTIFY_EVENT_UID_COUNTER_SIZE = 0x02,         // The size of the "UID Counter".
     AVRC_TG_NOTIFY_EVENT_ID_VOLUME_SIZE = 0x01,           // The size of the "Absolute Volume".
+    AVRC_CT_NOTIFY_PARAMETER_LENGTH = 0x0005,       	  // The length of the "CT Parameter Length".
 };
 
 /**
@@ -222,6 +223,16 @@ public:
         return eventId_;
     }
 
+    /**
+    * @brief Gets the "Volume".
+    *
+    * @return The value of the "Volume".
+    */
+    uint8_t GetVolume(void) const
+    {
+        return volume_;
+    }
+
     /**
      * @brief Gets the "Playback interval".
      *
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.cpp b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.cpp
index 18b2f00..64c26ab 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.cpp
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.cpp
@@ -138,6 +138,18 @@ uint8_t AvrcTgPacket::GetOpCode(Packet *pkt)
     return opCode;
 }
 
+uint8_t AvrcTgPacket::GetCrCode(Packet *pkt)
+{
+    HILOGI("enter");
+
+    uint8_t crCode = AVRC_TG_RSP_CODE_NOT_IMPLEMENTED;
+    if (PacketPayloadRead(pkt, &crCode, AVRC_TG_AVC_COMMON_CTYPE_OFFSET, 1) != 1) {
+        crCode = AVRC_TG_RSP_CODE_NOT_IMPLEMENTED;
+    }
+
+    return crCode;
+}
+
 uint8_t AvrcTgPacket::GetVendorPdu(Packet *pkt)
 {
     HILOGI("enter");
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.h b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.h
index 2740865..572edf6 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.h
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_packet.h
@@ -238,6 +238,14 @@ public:
      */
     static uint8_t GetOpCode(Packet *pkt);
 
+    /**
+     * @brief Gets the response code of the specified command frame.
+     *
+     * @param[in] pkt The packet of the specified command frame.
+     * @return The response code of the specified command frame.
+     */
+    static uint8_t GetCrCode(Packet *pkt) ;
+
     /**
      * @brief Gets the PDU ID of the VENDOR DEPENDENT command frame.
      *
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.cpp b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.cpp
index fdecbc1..3542ca1 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.cpp
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.cpp
@@ -25,9 +25,13 @@
 #include "avrcp_tg_vendor_player_application_settings.h"
 #include "power_manager.h"
 #include "log_util.h"
+#include "audio_info.h"
+#include "audio_system_manager.h"
 
 namespace OHOS {
 namespace bluetooth {
+#define VOL_NOT_SUPPORTED -1
+
 bool AvrcTgProfile::g_isEnabled = false;
 
 AvrcTgProfile::AvrcTgProfile(uint16_t features, uint32_t companyId, uint16_t controlMtu, uint16_t browseMtu,
@@ -243,6 +247,7 @@ int AvrcTgProfile::Connect(const RawAddress &rawAddr) const
     result |= AvrcTgStateMachineManager::GetInstance()->AddControlStateMachine(rawAddr);
     if (result == BT_SUCCESS) {
         myObserver_->onConnectionStateChanged(rawAddr, static_cast<int>(BTConnectState::CONNECTING));
+        myObserver_->findService(rawAddr);
     }
 
     return result;
@@ -574,6 +579,47 @@ void AvrcTgProfile::ReceiveSubUnitCmd(const RawAddress &rawAddr, uint8_t label,
  * VENDOR COMMAND                                                 *
  ******************************************************************/
 
+void AvrcTgProfile::SendVendorCmd(
+    const RawAddress &rawAddr, const std::shared_ptr<AvrcTgVendorPacket> &pkt, AvrcTgSmEvent event)
+{
+    HILOGI("address: %{public}s, event: %{public}x", GET_ENCRYPT_AVRCP_ADDR(rawAddr), event);
+
+    AvrcTgConnectManager *cnManager = AvrcTgConnectManager::GetInstance();
+    /// Unprocessed vendor dependent command.
+    /// Sets the information which is used in the "CONNECTED" state of the control state machine.
+    cnManager->ClearVendorInfo(rawAddr);
+    cnManager->SetVendorPacket(rawAddr, pkt);
+
+    utility::Message msg(event);
+    AvrcTgStateMachineManager::GetInstance()->SendMessageToControlStateMachine(rawAddr, msg);
+}
+
+void AvrcTgProfile::RegisterNotification(const RawAddress &rawAddr, const std::vector<uint8_t> &events)
+{
+    HILOGI("address: %{public}s, events.size: %{public}zu", GET_ENCRYPT_AVRCP_ADDR(rawAddr), events.size());
+
+    AvrcTgConnectManager *cnManager = AvrcTgConnectManager::GetInstance();
+    for (auto event : events) {
+        cnManager->EnableNotifyState(rawAddr, event);
+
+        std::shared_ptr<AvrcTgNotifyPacket> notifyPkt =
+            std::make_shared<AvrcTgNotifyPacket>(event, AVRC_TG_CMD_CODE_NOTIFY, 0x0);
+        notifyPkt->AssemblePackets();
+        std::shared_ptr<AvrcTgVendorPacket> packet = notifyPkt;
+        SendVendorCmd(rawAddr, packet, AVRC_TG_SM_EVENT_REGISTER_NOTIFICATION);
+    }
+}
+
+void AvrcTgProfile::UnRegisterNotification(const RawAddress &rawAddr, const std::vector<uint8_t> &events)
+{
+    HILOGI("address: %{public}s", GET_ENCRYPT_AVRCP_ADDR(rawAddr));
+
+    AvrcTgConnectManager *cnManager = AvrcTgConnectManager::GetInstance();
+    for (auto event : events) {
+        cnManager->DisableNotifyState(rawAddr, event);
+    }
+}
+
 void AvrcTgProfile::SendVendorRsp(
     const RawAddress &rawAddr, std::shared_ptr<AvrcTgVendorPacket> &pkt, AvrcTgSmEvent event)
 {
@@ -1027,6 +1073,26 @@ void AvrcTgProfile::ReceiveAddToNowPlayingCmd(const RawAddress &rawAddr, uint8_t
     }
 }
 
+
+void AvrcTgProfile::SendSetAbsoluteVolumeCmd(const RawAddress &rawAddr, uint8_t volume)
+{
+    HILOGI("address: %{public}s, volume: %{public}x", GET_ENCRYPT_AVRCP_ADDR(rawAddr), volume);
+
+    std::shared_ptr<AvrcTgVendorPacket> packet =
+        std::make_shared<AvrcTgSavPacket>(AVRC_TG_CMD_CODE_CONTROL, volume, 0);
+    IPowerManager::GetInstance().StatusUpdate(RequestStatus::BUSY, PROFILE_NAME_AVRCP_TG, rawAddr);
+    SendVendorCmd(rawAddr, packet, AVRC_TG_SM_EVENT_SET_ABSOLUTE_VOLUME);
+    IPowerManager::GetInstance().StatusUpdate(RequestStatus::IDLE, PROFILE_NAME_AVRCP_TG, rawAddr);
+}
+
+void AvrcTgProfile::ReceiveSetAbsoluteVolumeRsp(const RawAddress &rawAddr, Packet *pkt)
+{
+    HILOGI("address: %{public}s", GET_ENCRYPT_AVRCP_ADDR(rawAddr));
+    AvrcTgSavPacket packet(pkt, 0);
+    HILOGI("address: %{public}s, volume: %{public}x, crcode: %{public}x",
+        GET_ENCRYPT_AVRCP_ADDR(rawAddr), packet.GetAbsoluteVolume(), packet.GetCrCode());
+}
+
 void AvrcTgProfile::SendSetAbsoluteVolumeRsp(const RawAddress &rawAddr, uint8_t volume, uint8_t label, int result)
 {
     HILOGI("rawAddr:%{public}s, volume:%{public}d, label:%{public}d, result:%{public}d",
@@ -1459,8 +1525,33 @@ void AvrcTgProfile::ReceiveRegisterNotificationCmd(const RawAddress &rawAddr, ui
             break;
         case AVRC_TG_EVENT_ID_VOLUME_CHANGED:
             if (notifyPkt->IsValid()) {
-                SetNotificationLabel(AVRC_TG_EVENT_ID_VOLUME_CHANGED, label);
-                myObserver_->getCurrentAbsoluteVolume(rawAddr, label);
+                HILOGI("volume:%{public}d, crCode:%{public}x",notifyPkt->GetVolume(), notifyPkt->GetCrCode());
+                switch (notifyPkt->GetCrCode()) {
+                    case AVRC_TG_RSP_CODE_INTERIM:
+                        if(volume_ == VOL_NOT_SUPPORTED) {
+                            volume_ = AudioStandard::AudioSystemManager::GetInstance()->GetVolume(
+                                AudioStandard::AudioStreamType::STREAM_MUSIC);
+                            int avrcpVolume = static_cast<int>(ceil(static_cast<double>(volume_) * 127 / 15));
+                            if (avrcpVolume > 127) avrcpVolume = 127;
+                            HILOGI("volume_:%{public}d, avrcpVolume:%{public}x", volume_, avrcpVolume);
+                            SendSetAbsoluteVolumeCmd(rawAddr, avrcpVolume);
+                        }
+                        break;
+                    case AVRC_TG_RSP_CODE_CHANGED: {
+                        volume_ = notifyPkt->GetVolume();
+                        std::vector<uint8_t> events;
+                        events.push_back(AVRC_EVENT_ID_VOLUME_CHANGED);
+                        RegisterNotification(rawAddr, events);
+                        myObserver_ ->handleVolumeChanged(rawAddr, volume_);
+                        break;
+                    }
+                    case AVRC_TG_CMD_CODE_NOTIFY:
+                        SetNotificationLabel(AVRC_TG_EVENT_ID_VOLUME_CHANGED, label);
+                        myObserver_->getCurrentAbsoluteVolume(rawAddr, label);
+                        break;
+                    default:
+                        break;
+                }
             }
             break;
         default:
@@ -1519,7 +1610,11 @@ void AvrcTgProfile::ReceiveVendorCmd(const RawAddress &rawAddr, uint8_t label, P
             ReceiveAddToNowPlayingCmd(rawAddr, label, pkt);
             break;
         case AVRC_TG_PDU_ID_SET_ABSOLUTE_VOLUME:
-            ReceiveSetAbsoluteVolumeCmd(rawAddr, label, pkt);
+            if(AvrcTgPacket::GetCrCode(pkt) == AVRC_TG_CMD_CODE_CONTROL) {
+                ReceiveSetAbsoluteVolumeCmd(rawAddr, label, pkt);
+            } else {
+                ReceiveSetAbsoluteVolumeRsp(rawAddr, pkt);
+            }
             break;
         case AVRC_TG_PDU_ID_REGISTER_NOTIFICATION:
             ReceiveRegisterNotificationCmd(rawAddr, label, pkt);
@@ -1811,6 +1906,8 @@ void AvrcTgProfile::ProcessChannelEventConnectIndEvt(
     HILOGI("rawAddr:%{public}s, connectId:%{public}d, event:%{public}d, result:%{public}d",
         GET_ENCRYPT_AVRCP_ADDR(rawAddr), connectId, event, result);
 
+    volume_ = VOL_NOT_SUPPORTED;
+
     myObserver_->onConnectionStateChanged(rawAddr, static_cast<int>(BTConnectState::CONNECTING));
 
     result = ExpainAvctResult(result);
@@ -1831,10 +1928,7 @@ void AvrcTgProfile::ProcessChannelEventConnectIndEvt(
                 myObserver_->setActiveDevice(rawAddr);
             }
             cnManager->DeleteDisconnectedDevice(rawAddr.GetAddress());
-            if (!IsSupportedBrowsing()) {
-                myObserver_->onConnectionStateChanged(rawAddr, static_cast<int>(BTConnectState::CONNECTED));
-                IPowerManager::GetInstance().StatusUpdate(RequestStatus::CONNECT_ON, PROFILE_NAME_AVRCP_TG, rawAddr);
-            }
+            myObserver_->findService(rawAddr);
         }
     }
 }
@@ -1951,6 +2045,8 @@ void AvrcTgProfile::ProcessChannelEventConnectCfmEvt(
 {
     HILOGI("rawAddr:%{public}s, connectId:%{public}d, event:%{public}d, result:%{public}d",
         GET_ENCRYPT_AVRCP_ADDR(rawAddr), connectId, event, result);
+    volume_ = VOL_NOT_SUPPORTED;
+
     AvrcTgConnectManager *cnManager = AvrcTgConnectManager::GetInstance();
     AvrcTgStateMachineManager *smManager = AvrcTgStateMachineManager::GetInstance();
     utility::Message msg(AVRC_TG_SM_EVENT_INVALID);
@@ -1968,6 +2064,13 @@ void AvrcTgProfile::ProcessChannelEventConnectCfmEvt(
         }
         cnManager->DeleteDisconnectedDevice(rawAddr.GetAddress());
         IPowerManager::GetInstance().StatusUpdate(RequestStatus::CONNECT_ON, PROFILE_NAME_AVRCP_TG, rawAddr);
+        // Register VOLUME_CHANGED Notification if supported Absoulute Volume
+        if(IsAbsoluteVolumeSupported(rawAddr))
+        {
+            std::vector<uint8_t> events;
+            events.push_back(AVRC_EVENT_ID_VOLUME_CHANGED);
+            RegisterNotification(rawAddr,events);
+        }
     } else {
         DeleteResource(rawAddr);
         myObserver_->onConnectionStateChanged(rawAddr, static_cast<int>(BTConnectState::DISCONNECTED));
@@ -2037,6 +2140,13 @@ void AvrcTgProfile::DeleteBrowseStateMachine(const RawAddress &rawAddr)
     AvrcTgStateMachineManager::GetInstance()->DeleteBrowseStateMachine(rawAddr);
 }
 
+bool AvrcTgProfile::IsAbsoluteVolumeSupported(const RawAddress &rawAddr)
+{
+    HILOGI("rawAddr:%{public}s", GET_ENCRYPT_AVRCP_ADDR(rawAddr));
+
+    return (features_ & AVRC_TG_FEATURE_CATEGORY_2) == AVRC_TG_FEATURE_CATEGORY_2;
+}
+
 int AvrcTgProfile::ExpainAvctResult(uint16_t avctRet)
 {
     HILOGI("avctRet:%{public}d", avctRet);
@@ -2169,5 +2279,26 @@ void AvrcTgProfile::SetNotificationLabel(uint8_t event, uint8_t label)
             break;
     }
 }
+
+void AvrcTgProfile::SetFeatures(const RawAddress &rawAddr, uint16_t features)
+{
+    HILOGI("rawAddr:%{public}s features:%{public}x", GET_ENCRYPT_AVRCP_ADDR(rawAddr), features);
+    features_ |= features;
+    if(AvrcTgConnectManager::GetInstance()->GetConnectInfo(rawAddr)->role_ == AVCT_ACPT)
+    {
+        if (!IsSupportedBrowsing()) {
+            myObserver_->onConnectionStateChanged(rawAddr, static_cast<int>(BTConnectState::CONNECTED));
+            IPowerManager::GetInstance().StatusUpdate(RequestStatus::CONNECT_ON, PROFILE_NAME_AVRCP_TG, rawAddr);
+        }
+        // Register VOLUME_CHANGED Notification if supported Absoulute Volume
+        if(IsAbsoluteVolumeSupported(rawAddr))
+        {
+            std::vector<uint8_t> events;
+            events.push_back(AVRC_EVENT_ID_VOLUME_CHANGED); // Volume Changed
+            RegisterNotification(rawAddr,events);
+        }
+    }
+}
+
 }  // namespace bluetooth
 }  // namespace OHOS
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.h b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.h
index 1986817..4d2a7ce 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.h
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_profile.h
@@ -61,6 +61,16 @@ public:
          */
         std::function<void(const RawAddress &rawAddr)> findCtService;
 
+        /**
+         * @brief Informs that want to find the AVRCP CT record of the specified device.
+         *
+         * SDP_ATTRIBUTE_SERVICE_CLASS_ID_LIST
+         * SDP_ATTRIBUTE_BLUETOOTH_PROFILE_DESCRIPTOR_LIST
+         * AVRC_TG_ATTRIBUTE_ID_SUPPORTED_FEATURES
+         * @param[in] rawAddr The address of the peer bluetooth device.
+         */
+        std::function<void(const RawAddress &rawAddr)> findService;
+
         /**
          * @brief Informs that the button is pressed.
          *
@@ -344,6 +354,8 @@ public:
          * @param[in] rawAddr  The address of the bluetooth device.
          */
         std::function<void(const RawAddress &rawAddr)> setActiveDevice;
+
+        std::function<void(const RawAddress &rawAddr, uint8_t volume)> handleVolumeChanged;
     };
 
     /**
@@ -538,6 +550,30 @@ public:
      * VENDOR COMMAND                                                 *
      ******************************************************************/
 
+    /**
+     * @brief Sends the command of the <b>RegisterNotification</b>.
+     *
+     * @param[in] rawAddr  The address of the bluetooth device.
+     * @param[in] events   The event for which the requires notification. Refer to <b>events</b>.
+     */
+    void RegisterNotification(const RawAddress &rawAddr, const std::vector<uint8_t> &events);
+
+    /**
+     * @brief Sends the command of the <b>UnRegisterNotification</b>.
+     *
+     * @param[in] rawAddr  The address of the bluetooth device.
+     * @param[in] events   The event for which the requires unotification. Refer to <b>events</b>.
+     */
+    static void UnRegisterNotification(const RawAddress &rawAddr, const std::vector<uint8_t> &events);
+
+    /**
+     * @brief Sends the command of the <b>VENDOR DEPENDENT</b>.
+     *
+     * @param[in] rawAddr The address of the bluetooth device.
+     * @param[in] pkt     The frame packet.
+     */
+    void SendVendorCmd(const RawAddress &rawAddr, const std::shared_ptr<AvrcTgVendorPacket> &pkt, AvrcTgSmEvent event);
+
     /**
      * @brief Sends the response of the <b>GetCapabilities</b>.
      *
@@ -740,6 +776,22 @@ public:
      */
     void SendAddToNowPlayingRsp(const RawAddress &rawAddr, int status, uint8_t label, int result);
 
+    /**
+     * @brief Sends the command of the <b>SetAbsoluteVolume</b>.
+     *
+     * @param[in] rawAddr The address of the bluetooth device.
+     * @param[in] volume  The percentage of the absolute volume. Refer to <b>AvrcAbsoluteVolume</b>.
+     */
+    void SendSetAbsoluteVolumeCmd(const RawAddress &rawAddr, uint8_t volume);
+
+    /**
+     * @brief Sends the command of the <b>SetAbsoluteVolume</b>.
+     *
+     * @param[in] rawAddr The address of the bluetooth device.
+     * @param[in] pkt  The packet of the frame.
+     */
+    void ReceiveSetAbsoluteVolumeRsp(const RawAddress &rawAddr, Packet *pkt);
+
     /**
      * @brief Sends the response of the <b>SetAbsoluteVolume</b>.
      *
@@ -989,6 +1041,9 @@ public:
      */
     void SetNotificationLabel(uint8_t event, uint8_t label);
 
+    // Set avrcp_tg feature by SDP_SERVICE_SEARCH_ATTR_RSP
+    void SetFeatures(const RawAddress &rawAddr, uint16_t features);
+
 private:
     /// The flag is used to indicate that the AVRCP TG profile is enabled or not.
     static bool g_isEnabled;
@@ -1019,6 +1074,8 @@ private:
     AvctMsgCallback msgCallback_ {nullptr};
     // Locks the local variable in a multi-threaded environment.
     std::recursive_mutex mutex_ {};
+
+    int8_t volume_ = -1;
     /**
      * @brief A deleted default constructor.
      */
@@ -1385,6 +1442,15 @@ private:
         return ((features_ & AVRC_TG_FEATURE_BROWSING) == AVRC_TG_FEATURE_BROWSING);
     }
 
+    /**
+     * @brief Checks  the AVRCP AbsoluteVolume is Supported or not.
+     *
+     * @return The result of the method execution.
+     * @retval true  The AbsoluteVolume Supported.
+     * @retval false The AbsoluteVolume is not Supported.
+     */
+    bool IsAbsoluteVolumeSupported(const RawAddress &rawAddr);
+
     /**
      * @brief Explains the response of the <b>AVCTP</b> function to the result.
      *
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.cpp b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.cpp
index 8fa46c2..2c77c35 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.cpp
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.cpp
@@ -14,7 +14,6 @@
  */
 
 #include "avrcp_tg_sdp.h"
-#include "sdp.h"
 
 namespace OHOS {
 namespace bluetooth {
@@ -132,6 +131,37 @@ int AvrcTgSdpManager::FindCtService(const RawAddress &rawAddr,
     return result;
 }
 
+// for SDP_SERVICE_SEARCH_ATTR_REQ
+int AvrcTgSdpManager::FindService(const RawAddress &rawAddr,
+    void (*callback)(const BtAddr *btAddr, const SdpService *serviceArray, uint16_t serviceNum, void *context))
+{
+    HILOGI("enter");
+
+    BtAddr btAddr;
+    rawAddr.ConvertToUint8(btAddr.addr);
+
+    BtUuid classIdList[AVRC_SERVICE_CLASS_ID_LIST_NUMBER];
+    classIdList[0].type = BT_UUID_16;
+    classIdList[0].uuid16 = AVRC_TG_AV_REMOTE_CONTROL;
+    SdpUuid sdpUuid = {
+        .uuidNum = AVRC_SERVICE_CLASS_ID_LIST_NUMBER,
+        .uuid = classIdList
+    };
+
+    SdpAttributeIdList attributeIdList;
+    attributeIdList.type = SDP_TYPE_LIST;
+
+    attributeIdList.attributeIdList.attributeIdNumber = AVRC_SDP_ATTRIBUTE_NUM;
+    attributeIdList.attributeIdList.attributeId[0] = SDP_ATTRIBUTE_SERVICE_CLASS_ID_LIST;
+    attributeIdList.attributeIdList.attributeId[1] = SDP_ATTRIBUTE_BLUETOOTH_PROFILE_DESCRIPTOR_LIST;
+    attributeIdList.attributeIdList.attributeId[2] = AVRC_TG_ATTRIBUTE_ID_SUPPORTED_FEATURES;
+
+    int result = SDP_ServiceSearchAttribute(&btAddr, &sdpUuid, attributeIdList, nullptr, callback);
+    (result == BT_SUCCESS) ? (result = BT_SUCCESS) : (result = RET_BAD_STATUS);
+
+    return result;
+}
+
 int AvrcTgSdpManager::AddProtocolDescriptorList()
 {
     HILOGI("enter");
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.h b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.h
index 27a7c43..5a7bbdf 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.h
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_sdp.h
@@ -18,9 +18,12 @@
 
 #include "avrcp_tg_internal.h"
 #include "raw_address.h"
+#include "sdp.h"
 
 namespace OHOS {
 namespace bluetooth {
+#define AVRC_SDP_ATTRIBUTE_NUM 3
+
 /// The attribute id of the supported features.
 const uint16_t AVRC_TG_ATTRIBUTE_ID_SUPPORTED_FEATURES = 0x0311;
 
@@ -73,6 +76,18 @@ public:
     static int FindCtService(const RawAddress &rawAddr,
         void (*callback)(const BtAddr *btAddr, const uint32_t *handleArray, uint16_t handleNum, void *context));
 
+    /**
+     * @brief Finds the service record from the SDP.
+     *
+     * @param[in] rawAddr  The address of the bluetooth device.
+     * @param[in] callback The callback function that receives the search result.
+     * @return The result of the method execution.
+     * @retval BT_SUCCESS   Execute success.
+     * @retval RET_BAD_STATUS Execute failure.
+     */
+    static int FindService(const RawAddress &rawAddr,
+        void (*callback)(const BtAddr *btAddr, const SdpService *serviceArray, uint16_t serviceNum, void *context));
+
 private:
     uint32_t sdpHandle_;  // The handle got from the SDP.
     uint32_t features_;   // The features supported by the AVRCP TG service.
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.cpp b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.cpp
index 4575c89..5ac5a82 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.cpp
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.cpp
@@ -30,6 +30,8 @@
 #include "timer.h"
 #include "log_util.h"
 
+#include "avrcp_tg_volume_interface.h"
+
 namespace OHOS {
 namespace bluetooth {
 void AvrcpTgService::ObserverImpl::OnConnectionStateChanged(const std::string &addr, int state)
@@ -371,6 +373,37 @@ IProfileAvrcpTg *AvrcpTgService::AVSessionObserverImpl::GetService(void)
     return static_cast<IProfileAvrcpTg *>(svManager->GetProfileService(PROFILE_NAME_AVRCP_TG));
 }
 
+
+void AvrcpTgService::AVControllerObserverImpl::OnAVCallMetaDataChange(const OHOS::AVSession::AVCallMetaData& avCallMetaData)
+{
+    HILOGI("enter");
+}
+
+void AvrcpTgService::AVControllerObserverImpl::OnAVCallStateChange(const OHOS::AVSession::AVCallState& avCallState)
+{
+    HILOGI("enter");
+}
+
+void AvrcpTgService::AVControllerObserverImpl::OnSessionEventChange(const std::string& event, const AAFwk::WantParams& args)
+{
+    HILOGI("enter");
+}
+
+void AvrcpTgService::AVControllerObserverImpl::OnQueueItemsChange(const std::vector<OHOS::AVSession::AVQueueItem>& items)
+{
+    HILOGI("enter");
+}
+
+void AvrcpTgService::AVControllerObserverImpl::OnQueueTitleChange(const std::string& title)
+{
+    HILOGI("enter");
+}
+
+void AvrcpTgService::AVControllerObserverImpl::OnExtrasChange(const AAFwk::WantParams& extras)
+{
+    HILOGI("enter");
+}
+
 void AvrcpTgService::AVControllerObserverImpl::OnSessionDestroy()
 {
     HILOGI("enter");
@@ -401,6 +434,11 @@ void AvrcpTgService::AVControllerObserverImpl::OnValidCommandChange(const std::v
     HILOGI("enter");
 }
 
+void AvrcpTgService::AVControllerObserverImpl::OnOutputDeviceChange(const int32_t connectionState, const OHOS::AVSession::OutputDeviceInfo &outputDeviceInfo)
+{
+    HILOGI("enter");
+}
+
 IProfileAvrcpTg *AvrcpTgService::AVControllerObserverImpl::GetService(void)
 {
     HILOGI("enter");
@@ -427,6 +465,7 @@ AvrcpTgService::AvrcpTgService() : utility::Context(PROFILE_NAME_AVRCP_TG, "1.6.
         std::bind(&AvrcpTgService::OnProfileDisabled, this, BT_SUCCESS),
         std::bind(&AvrcpTgService::OnConnectionStateChanged, this, _1, _2),
         std::bind(&AvrcpTgService::FindCtService, this, _1),
+        std::bind(&AvrcpTgService::FindService, this, _1),
         std::bind(&AvrcpTgService::OnButtonPressed, this, _1, _2, _3),
         std::bind(&AvrcpTgService::OnButtonReleased, this, _1, _2, _3),
         std::bind(&AvrcpTgService::HoldButton, this, _1, _2, _3),
@@ -454,6 +493,7 @@ AvrcpTgService::AvrcpTgService() : utility::Context(PROFILE_NAME_AVRCP_TG, "1.6.
         std::bind(&AvrcpTgService::GetCurrentAbsoluteVolume, this, _1, _2),
         std::bind(&AvrcpTgService::SetPlaybackInterval, this, _1, _2),
         std::bind(&AvrcpTgService::SetActiveDevice, this, _1),
+        std::bind(&AvrcpTgService::HandleVolumeChanged, this, _1, _2),
     };
     pfObserver_ = std::make_unique<AvrcTgProfile::Observer>(observer);
 }
@@ -493,6 +533,15 @@ void AvrcpTgService::InitFeatures()
     features_ |= AVRC_TG_FEATURE_NOTIFY_ABSOLUTE_VOLUME_CHANGED;
 }
 
+void AvrcpTgService::SetFeatures(const RawAddress &rawAddr, uint16_t features)
+{
+    if (!IsAbsoluteVolumeEnabled(rawAddr)) {
+        features &= ~AVRC_TG_FEATURE_CATEGORY_2;
+    }
+    HILOGI("rawAddr: %{public}s features: 0X%{public}x", GET_ENCRYPT_AVRCP_ADDR(rawAddr), features);
+    profile_->SetFeatures(rawAddr, features);
+}
+
 /******************************************************************
  * REGISTER / UNREGISTER OBSERVER                                 *
  ******************************************************************/
@@ -557,6 +606,8 @@ void AvrcpTgService::EnableNative(void)
 #ifdef AVRCP_AVSESSION
     RegisterAvSessionControl();
 #endif
+    AvrcpTgVolumeInterfaceImpl::GetInstance()->RegisterVolumeEventCallback();
+
     IAdapterConfig *config = AdapterConfig::GetInstance();
     config->GetValue(SECTION_AVRCP_TG_SERVICE, PROPERTY_MAX_CONNECTED_DEVICES, maxConnection_);
 
@@ -590,6 +641,8 @@ void AvrcpTgService::DisableNative(void)
 {
     HILOGI("enter");
 
+    AvrcpTgVolumeInterfaceImpl::GetInstance()->UnregisterVolumeEventCallback();
+
     if (DisableProfile() != BT_SUCCESS) {
         OnProfileDisabled(RET_BAD_STATUS);
     }
@@ -683,7 +736,8 @@ int AvrcpTgService::EnableProfile(void)
     config->GetValue(SECTION_AVRCP_TG_SERVICE, PROPERTY_CONTROL_MTU, controlMtu);
     config->GetValue(SECTION_AVRCP_TG_SERVICE, PROPERTY_BROWSE_MTU, browseMtu);
 
-    profile_ = std::make_unique<AvrcTgProfile>(features_,
+    // the features should be inited in ParseSDPInformation
+    profile_ = std::make_unique<AvrcTgProfile>(AVRC_TG_FEATURE_INVALID_FEATURE,
         AVRC_TG_DEFAULT_BLUETOOTH_SIG_COMPANY_ID,
         controlMtu,
         browseMtu,
@@ -752,6 +806,7 @@ void AvrcpTgService::SetActiveDevice(const RawAddress &rawAddr)
     if (IsEnabled()) {
         profile_->SetActiveDevice(rawAddr);
         stub::MediaService::GetInstance()->SetActiveDevice(rawAddr.GetAddress());
+        AvrcpTgVolumeInterfaceImpl::GetInstance()->setActiveDevice(rawAddr.GetAddress());
     }
 }
 
@@ -952,6 +1007,54 @@ void AvrcpTgService::RejectPassiveConnect(const RawAddress &rawAddr)
     } while (false);
 }
 
+// Parse AVRCP SDP Information
+// supports browsing || supports advanced control
+void AvrcpTgService::ParseSDPInformation(
+    const BtAddr *btAddr, const SdpService *serviceArray, uint16_t serviceNum)
+{
+    HILOGI("serviceNum(%{public}d)\n", serviceNum);
+
+    uint16_t peer_features = 0;
+    uint16_t peer_avrcp_version = 0;
+
+    for (int i = 0; i < serviceNum; i++) {
+        HILOGI("uuid16: %{public}4x\n", serviceArray[i].classId->uuid16);
+        if (serviceArray[i].classId->uuid16 == UUID_SERVCLASS_AV_REMOTE_CONTROL) {
+            peer_avrcp_version = serviceArray[i].profileDescriptor->versionNumber;
+            HILOGI("peer_avrcp_version: %{public}x\n", peer_avrcp_version);
+            if(peer_avrcp_version >= AVRC_REV_1_4) {
+                uint16_t data = *(uint16_t*)serviceArray[i].attribute[0].attributeValue;
+                HILOGI("data: %{public}x\n", data);
+                if (data & AVRC_TG_FEATURE_CATEGORY_2) {
+                    peer_features |= AVRC_TG_FEATURE_CATEGORY_2;
+                }
+                if (data & AVRC_TG_FEATURE_BROWSING) {
+                    peer_features |= AVRC_TG_FEATURE_BROWSING;
+                }
+            }
+        }
+        if (serviceArray[i].classId->uuid16 == UUID_SERVCLASS_AV_REM_CTRL_TARGET) {
+            peer_avrcp_version = serviceArray[i].profileDescriptor->versionNumber;
+            HILOGI("peer_avrcp_version: %{public}x\n", peer_avrcp_version);
+            if(peer_avrcp_version >= AVRC_REV_1_4) {
+                uint16_t data = *(uint16_t*)serviceArray[i].attribute[0].attributeValue;
+                HILOGI("data: %{public}x\n", data);
+                if (data & AVRC_TG_FEATURE_CATEGORY_2) {
+                    peer_features |= AVRC_TG_FEATURE_CATEGORY_2;
+                }
+            }
+        }
+    }
+
+    HILOGI("peer_avrcp_version(%{public}x) peer_features(%{public}x)\n",peer_avrcp_version, peer_features);
+    auto servManager = IProfileManager::GetInstance();
+    auto service = static_cast<AvrcpTgService *>(servManager->GetProfileService(PROFILE_NAME_AVRCP_TG));
+    RawAddress rawAddr(RawAddress::ConvertToString(btAddr->addr));
+    if (service != nullptr) {
+        service->GetDispatcher()->PostTask(std::bind(&AvrcpTgService::SetFeatures, service, rawAddr, peer_features));
+    }
+}
+
 void AvrcpTgService::FindCtService(const RawAddress &rawAddr)
 {
     HILOGI("rawAddr: %{public}s", GET_ENCRYPT_AVRCP_ADDR(rawAddr));
@@ -978,6 +1081,34 @@ void AvrcpTgService::FindCtServiceCallback(
     }
 }
 
+// for SDP_SERVICE_SEARCH_ATTR_REQ
+void AvrcpTgService::FindService(const RawAddress &rawAddr)
+{
+    HILOGI("rawAddr: %{public}s", GET_ENCRYPT_AVRCP_ADDR(rawAddr));
+
+    if (sdpManager_->FindService(rawAddr, FindServiceCallback) != BT_SUCCESS) {
+        RejectPassiveConnect(rawAddr);
+    }
+}
+
+void AvrcpTgService::FindServiceCallback(
+   const BtAddr *btAddr, const SdpService *serviceArray, uint16_t serviceNum, void *context)
+{
+    HILOGI("serviceNum: %{public}d", serviceNum);
+
+    auto servManager = IProfileManager::GetInstance();
+    auto service = static_cast<AvrcpTgService *>(servManager->GetProfileService(PROFILE_NAME_AVRCP_TG));
+    RawAddress rawAddr(RawAddress::ConvertToString(btAddr->addr));
+    if (service != nullptr) {
+        if (serviceNum > 0) {
+            ParseSDPInformation(btAddr, serviceArray, serviceNum);
+            // service->GetDispatcher()->PostTask(std::bind(&AvrcpTgService::AcceptPassiveConnect, service, rawAddr));
+        } else {
+            service->GetDispatcher()->PostTask(std::bind(&AvrcpTgService::RejectPassiveConnect, service, rawAddr));
+        }
+    }
+}
+
 #ifdef AVRCP_AVSESSION
 /******************************************************************
  * PASS THROUGH COMMAND                                           *
@@ -2001,6 +2132,46 @@ void AvrcpTgService::OnGetTotalNumberOfItemsNative(
  * ABSOLUTE VOLUME                                                *
  ******************************************************************/
 
+int AvrcpTgService::SetAbsoluteVolumeCmd(const RawAddress &rawAddr, uint8_t volume)
+{
+    HILOGI("addr: %{public}s, volume: %{public}d", GET_ENCRYPT_AVRCP_ADDR(rawAddr), volume);
+
+    int result = RET_BAD_STATUS;
+
+    do {
+        if (!IsEnabled()) {
+            break;
+        }
+
+        if (GetDeviceState(rawAddr) != static_cast<int>(BTConnectState::CONNECTED)) {
+            break;
+        }
+        RawAddress peerAddr(rawAddr.GetAddress());
+        GetDispatcher()->PostTask(std::bind(&AvrcpTgService::SetAbsoluteVolumeNative, this, peerAddr, volume));
+        result = BT_SUCCESS;
+    } while (false);
+
+    return result;
+}
+
+void AvrcpTgService::SetAbsoluteVolumeNative(RawAddress rawAddr, uint8_t volume)
+{
+    HILOGI("addr: %{public}s, volume: %{public}d", GET_ENCRYPT_AVRCP_ADDR(rawAddr), volume);
+
+    do {
+        if (!IsEnabled()) {
+            break;
+        }
+
+        if (GetDeviceState(rawAddr) != static_cast<int>(BTConnectState::CONNECTED)) {
+            break;
+        }
+
+        profile_->SendSetAbsoluteVolumeCmd(rawAddr, volume);
+    } while (false);
+}
+
+
 void AvrcpTgService::SetAbsoluteVolume(const RawAddress &rawAddr, uint8_t volume, uint8_t label) const
 {
     HILOGI("addr:%{public}s, volume:%{public}d, label:%{public}d", GET_ENCRYPT_AVRCP_ADDR(rawAddr), volume, label);
@@ -2045,6 +2216,12 @@ void AvrcpTgService::OnSetAbsoluteVolumeNative(RawAddress rawAddr, uint8_t volum
     } while (false);
 }
 
+void AvrcpTgService::HandleVolumeChanged(RawAddress rawAddr, uint8_t volume)
+{
+    HILOGI("addr: %{public}s, receive frome remote volume: %{public}d", GET_ENCRYPT_AVRCP_ADDR(rawAddr), volume);
+    AvrcpTgVolumeInterfaceImpl::GetInstance()->setVolume(volume);
+}
+
 /******************************************************************
  * NOTIFICATION                                                   *
  ******************************************************************/
@@ -2614,6 +2791,19 @@ void AvrcpTgService::ProcessChannelEvent(
         GET_ENCRYPT_AVRCP_ADDR(rawAddr), connectId, event, result);
 
     if (!IsDisabled()) {
+        switch (event) {
+            case AVCT_CONNECT_IND_EVT:
+            case AVCT_CONNECT_CFM_EVT:
+                AvrcpTgVolumeInterfaceImpl::GetInstance()->DeviceConnected(rawAddr,
+                    [=](int volume){SetAbsoluteVolumeCmd(rawAddr, volume);});
+                break;
+            case AVCT_DISCONNECT_IND_EVT:
+            case AVCT_DISCONNECT_CFM_EVT:
+                AvrcpTgVolumeInterfaceImpl::GetInstance()->DeviceDisconnected(rawAddr);
+                break;
+            default:
+                break;
+        }
         profile_->ProcessChannelEvent(rawAddr, connectId, event, result, context);
     }
 }
@@ -2687,13 +2877,13 @@ uint8_t AvrcpTgService::ConvertPlayState(const int32_t state) const
 #ifdef AVRCP_AVSESSION
     switch (state) {
         case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_INITIAL:
-        case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_PREPARING:
+        case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_PREPARE:
         case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_MAX:
             break;
-        case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_PLAYING:
+        case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_PLAY:
             ret = AVRC_PLAY_STATUS_PLAYING;
             break;
-        case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_PAUSED:
+        case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_PAUSE:
             ret = AVRC_PLAY_STATUS_PAUSED;
             break;
         case OHOS::AVSession::AVPlaybackState::PLAYBACK_STATE_FAST_FORWARD:
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.h b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.h
index 5df5bf5..c79553d 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.h
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_service.h
@@ -31,6 +31,17 @@
 #include "avsession_manager.h"
 #include "avsession_errors.h"
 #endif
+// add for Parse AVRCP SDP search result
+/* Audio/Video Control profile */
+#define UUID_SERVCLASS_AV_REM_CTRL_TARGET 0X110C
+/* Advanced Audio Distribution profile */
+#define UUID_SERVCLASS_ADV_AUDIO_DISTRIBUTION 0X110D
+/* Audio/Video Control profile */
+#define UUID_SERVCLASS_AV_REMOTE_CONTROL 0X110E
+/* Audio/Video Control profile */
+#define UUID_SERVCLASS_AV_REM_CTRL_CONTROL 0X110F
+/* Audio/Video Remote Control profile version */
+#define AVRC_REV_1_4 0x0104
 namespace OHOS {
 namespace bluetooth {
 /**
@@ -376,13 +387,20 @@ public:
          * @brief A destructor used to delete the <b>AVControllerObserverImpl</b> instance.
          */
         ~AVControllerObserverImpl() = default;
+        void OnAVCallMetaDataChange(const OHOS::AVSession::AVCallMetaData& avCallMetaData) override;
+        void OnAVCallStateChange(const OHOS::AVSession::AVCallState& avCallState) override;
+        void OnSessionEventChange(const std::string& event, const AAFwk::WantParams& args) override;
+        void OnQueueItemsChange(const std::vector<OHOS::AVSession::AVQueueItem>& items) override;
+        void OnQueueTitleChange(const std::string& title) override;
+        void OnExtrasChange(const AAFwk::WantParams& extras) override;
 
         void OnSessionDestroy() override;
         void OnPlaybackStateChange(const OHOS::AVSession::AVPlaybackState &state) override;
         void OnMetaDataChange(const OHOS::AVSession::AVMetaData &data) override;
         void OnActiveStateChange(bool isActive) override;
         void OnValidCommandChange(const std::vector<int32_t> &cmds) override;
-        void OnOutputDeviceChange(const OHOS::AVSession::OutputDeviceInfo &outputDeviceInfo) override {};
+        void OnOutputDeviceChange(const int32_t connectionState,
+            const OHOS::AVSession::OutputDeviceInfo &outputDeviceInfo) override;
     private:
         IProfileAvrcpTg *GetService(void);
     };
@@ -821,6 +839,19 @@ public:
      * ABSOLUTE VOLUME                                                *
      ******************************************************************/
 
+    /**
+     * @brief Sets an absolute volume to be used by the rendering device.
+     *
+     * @details Switch to the thread of the AVRCP CT service in this method.
+     * @param[in] rawAddr The address of the bluetooth device.
+     * @param[in] volume  The percentage of the absolute volume. Refer to <b>AvrcAbsoluteVolume</b>.
+     * @return The result of the method execution.
+     * @retval BT_SUCCESS   Execute success.
+     * @retval RET_NO_SUPPORT Not support.
+     * @retval RET_BAD_STATUS Execute failure.
+     */
+    int SetAbsoluteVolumeCmd(const RawAddress &rawAddr, uint8_t volume);
+
     /**
      * @brief Responds the data of the <b>SetAbsoluteVolume</b>.
      *
@@ -831,6 +862,17 @@ public:
      */
     void OnSetAbsoluteVolume(const RawAddress &rawAddr, uint8_t volume, uint8_t label) override;
 
+    /**
+     * @brief The absolute volume switch of the bluetooth device is enabled or not
+     *
+     * @details Switch to the thread of the AVRCP TG service in this function.
+     * @param[in] rawAddr The address of the bluetooth device.
+     * @return The result of the absolute volume switch.
+     * @retval true  The absolute volume switch is enabled.
+     * @retval false The absolute volume switch is not enabled.
+     */
+    bool IsAbsoluteVolumeEnabled(const RawAddress &rawAddr){return true;};
+
     /******************************************************************
      * NOTIFICATION                                                   *
      ******************************************************************/
@@ -1109,6 +1151,15 @@ private:
 
     void InitFeatures();
 
+    // Set avrcp_tg feature by SDP_SERVICE_SEARCH_ATTR_RSP
+    /**
+     * @brief Set the features.
+     *
+     * @param[in] rawAddr The address of the bluetooth device.
+     * @param[in] features The features of the bluetooth device.
+     */
+    void SetFeatures(const RawAddress &rawAddr, uint16_t features);
+
     /******************************************************************
      * CONNECTION                                                     *
      ******************************************************************/
@@ -1155,6 +1206,16 @@ private:
      */
     void RejectPassiveConnect(const RawAddress &rawAddr);
 
+    // parse SDP_SERVICE_SEARCH_ATTR_RSP
+    /**
+     * @brief The parse function, which parse SDP search result.
+     *
+     * @param[in] btAddr      The address of the peer Bluetooth device.
+     * @param[in] serviceArray The list of handle to a qualifying service.
+     * @param[in] serviceNum The number of handle to a qualifying service.
+     */
+    static void ParseSDPInformation(const BtAddr *btAddr, const SdpService *serviceArray, uint16_t serviceNum);
+
     /**
      * @brief Finds the AVRCP TG record of the specified device.
      *
@@ -1173,6 +1234,27 @@ private:
     static void FindCtServiceCallback(
         const BtAddr *btAddr, const uint32_t *handleArray, uint16_t handleCount, void *context);
 
+    /**
+     * @brief Finds the AVRCP TG record of the specified device.
+     *
+     * SDP_ATTRIBUTE_SERVICE_CLASS_ID_LIST
+     * SDP_ATTRIBUTE_BLUETOOTH_PROFILE_DESCRIPTOR_LIST
+     * AVRC_TG_ATTRIBUTE_ID_SUPPORTED_FEATURES
+     * @param[in] rawAddr The address of the peer bluetooth device.
+     */
+    void FindService(const RawAddress &rawAddr);
+
+    /**
+     * @brief The callback function, which register into the SDP for receiving the search result.
+     *
+     * @param[in] btAddr      The address of the peer Bluetooth device.
+     * @param[in] serviceArray The list of handle to a qualifying service.
+     * @param[in] serviceNum The number of handle to a qual ifying service.
+     * @param[in] context     The context is used to send the event in the callback.
+     */
+    static void FindServiceCallback(
+        const BtAddr *btAddr, const SdpService *serviceArray, uint16_t serviceNum, void *context);
+
     /******************************************************************
      * PASS THROUGH COMMAND                                           *
      ******************************************************************/
@@ -1681,6 +1763,14 @@ private:
      * ABSOLUTE VOLUME                                                *
      ******************************************************************/
 
+    /**
+     * @brief Sets an absolute volume to be used by the rendering device.
+     *
+     * @param[in] rawAddr The address of the bluetooth device.
+     * @param[in] volume  The percentage of the absolute volume. Refer to <b>AvrcAbsoluteVolume</b>.
+     */
+    void SetAbsoluteVolumeNative(RawAddress rawAddr, uint8_t volume);
+
     /**
      * @brief Sets an absolute volume to be used by the rendering device.
      *
@@ -1699,6 +1789,8 @@ private:
      */
     void OnSetAbsoluteVolumeNative(RawAddress rawAddr, uint8_t volume, uint8_t label);
 
+    void HandleVolumeChanged(RawAddress rawAddr, uint8_t volume);
+
     /******************************************************************
      * NOTIFICATION                                                   *
      ******************************************************************/
diff --git a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_state_machine.cpp b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_state_machine.cpp
index eac2ae0..5b367fd 100644
--- a/services/bluetooth/service/src/avrcp_tg/avrcp_tg_state_machine.cpp
+++ b/services/bluetooth/service/src/avrcp_tg/avrcp_tg_state_machine.cpp
@@ -504,7 +504,13 @@ void AvrcTgStateMachineManager::StateMachine::CtConnected::ToCommonEvent()
     std::shared_ptr<AvrcTgVendorPacket> packet = cnManager->GetVendorPacket(rawAddr_);
     Packet *pkt = packet->PopAssembledPacket();
 
-    AVCT_SendMsgReq(cnManager->GetConnectId(rawAddr_), packet->GetLabel(), AVCT_RESPONSE, pkt);
+    uint8_t crCode = packet->GetCrCode();
+    HILOGI("CrCode: 0X%{public}2x ", crCode);
+    if(crCode == AVRC_TG_CMD_CODE_NOTIFY || crCode == AVRC_TG_CMD_CODE_CONTROL) {
+        AVCT_SendMsgReq(cnManager->GetConnectId(rawAddr_), packet->GetLabel(), AVCT_COMMAND, pkt);
+    } else {
+        AVCT_SendMsgReq(cnManager->GetConnectId(rawAddr_), packet->GetLabel(), AVCT_RESPONSE, pkt);
+    }
     PacketFree(pkt);
 
     if (packet->IsPacketExist()) {
diff --git a/services/bluetooth/service/src/classic/classic_adapter.cpp b/services/bluetooth/service/src/classic/classic_adapter.cpp
index 412d7e8..753b668 100644
--- a/services/bluetooth/service/src/classic/classic_adapter.cpp
+++ b/services/bluetooth/service/src/classic/classic_adapter.cpp
@@ -997,7 +997,13 @@ void ClassicAdapter::HandleInquiryResult(
     HILOGI("enter");
 
     std::lock_guard<std::recursive_mutex> lk(pimpl->syncMutex_);
-    discoveryState_ = DISCOVERYING;
+    if (discoveryState_ == DISCOVERY_STOPED) {
+        HILOGE("Faild, discoveryState_ == DISCOVERY_STOPED");
+        return;
+    } else if (discoveryState_ == DISCOVERY_STARTED) {
+        discoveryState_ = DISCOVERYING;
+        HILOGI("Start, change discoveryState_ from DISCOVERY_STARTED to DISCOVERYING");
+    }
 
     RawAddress device = RawAddress::ConvertToString(addr.addr);
     std::shared_ptr<ClassicRemoteDevice> remoteDevice = FindRemoteDevice(device);
@@ -1173,8 +1179,8 @@ void ClassicAdapter::SSPConfirmReq(const BtAddr &addr, int reqType, int number,
 
     RawAddress device = RawAddress::ConvertToString(addr.addr);
     std::shared_ptr<ClassicRemoteDevice> remoteDevice = FindRemoteDevice(device);
-    remoteDevice->SetPairConfirmState(PAIR_CONFIRM_STATE_USER_CONFIRM);
     remoteDevice->SetPairConfirmType(reqType);
+    pinMode_ = true;
     int remoteIo = remoteDevice->GetIoCapability();
     if (remoteDevice->GetPairedStatus() == PAIR_CANCELING) {
         UserConfirmAutoReply(device, reqType, false);
@@ -1192,7 +1198,6 @@ void ClassicAdapter::PinCodeReq(const BtAddr &addr)
 
     RawAddress device = RawAddress::ConvertToString(addr.addr);
     std::shared_ptr<ClassicRemoteDevice> remoteDevice = FindRemoteDevice(device);
-    remoteDevice->SetPairConfirmState(PAIR_CONFIRM_STATE_USER_CONFIRM);
     remoteDevice->SetPairConfirmType(PAIR_CONFIRM_TYPE_PIN_CODE);
     pinMode_ = true;
     if (remoteDevice->GetRemoteName().empty()) {
@@ -1560,6 +1565,7 @@ void ClassicAdapter::ReceiveSimplePairComplete(const BtAddr &addr, uint8_t statu
             remoteDevice->SetPairedStatus(PAIR_NONE);
             /// Send the failed notification to APP.
             SendPairStatusChanged(ADAPTER_BREDR, device, PAIR_NONE);
+            pinMode_ = false;
         }
     }
 }
@@ -1590,6 +1596,7 @@ void ClassicAdapter::ReceiveAuthenticationComplete(const BtAddr &addr, uint8_t s
         remoteDevice->SetPairedStatus(PAIR_NONE);
         /// Send the failed notification to APP.
         SendPairStatusChanged(ADAPTER_BREDR, device, PAIR_NONE);
+        pinMode_ = false;
     } else {
         if (remoteDevice->GetPairedStatus() == PAIR_PAIRING) {
             remoteDevice->SetPairedStatus(PAIR_PAIRED);
@@ -1824,7 +1831,7 @@ bool ClassicAdapter::StartPair(const RawAddress &device)
         HILOGE("GAPIF_AuthenticationReq failed!");
         return false;
     }
-
+    remoteDevice->SetPairConfirmState(PAIR_CONFIRM_STATE_USER_CONFIRM);
     DeleteLinkKey(remoteDevice);
     remoteDevice->SetPairedStatus(PAIR_PAIRING);
     SendPairStatusChanged(ADAPTER_BREDR, device, PAIR_PAIRING);
@@ -1943,14 +1950,25 @@ bool ClassicAdapter::SetDevicePairingConfirmation(const RawAddress &device, bool
         return ret;
     }
 
+    int state = it->second->GetPairConfirmType();
+    const uint8_t defPinCodeLength = 4;  //indicate the max value of the default pincode
+    const uint8_t defPinCode[defPinCodeLength] = {'0', '0', '0', '0'};  //The default pincode is "0000".
     it->second->SetPairConfirmState(PAIR_CONFIRM_STATE_USER_CONFIRM_REPLY);
     it->second->SetPairConfirmType(PAIR_CONFIRM_TYPE_INVALID);
 
     BtAddr btAddr = ConvertToBtAddr(device);
     if (it->second->GetPairedStatus() == PAIR_CANCELING || accept == false) {
-        ret = (GAPIF_UserConfirmRsp(&btAddr, GAP_NOT_ACCEPT) == BT_SUCCESS);
+        if (state == PAIR_CONFIRM_TYPE_PIN_CODE) {
+            ret = (GAPIF_PinCodeRsp(&btAddr, GAP_NOT_ACCEPT, defPinCode, defPinCodeLength) == BT_SUCCESS);
+        } else {
+            ret = (GAPIF_UserConfirmRsp(&btAddr, GAP_NOT_ACCEPT) == BT_SUCCESS);
+        }
     } else {
-        ret = (GAPIF_UserConfirmRsp(&btAddr, GAP_ACCEPT) == BT_SUCCESS);
+        if (state == PAIR_CONFIRM_TYPE_PIN_CODE) {
+            ret = (GAPIF_PinCodeRsp(&btAddr, GAP_ACCEPT, defPinCode, defPinCodeLength) == BT_SUCCESS);
+        } else {
+            ret = (GAPIF_UserConfirmRsp(&btAddr, GAP_ACCEPT) == BT_SUCCESS);
+        }
     }
     ClassicUtils::CheckReturnValue("ClassicAdapter", "GAPIF_UserConfirmRsp", ret);
 
@@ -2095,12 +2113,8 @@ void ClassicAdapter::ReceiveDisconnectionComplete(uint8_t status, uint16_t conne
             /// Set the pair flag and pair state.
             device.second->SetPairedStatus(PAIR_NONE);
             /// Send the failed notification to APP.
-            bool bondFromLocal = device.second->IsBondedFromLocal();
-            HILOGI("bondFromLocal = %{public}d", bondFromLocal);
-            if (!bondFromLocal) {
-                RawAddress address(device.second->GetAddress());
-                SendPairStatusChanged(ADAPTER_BREDR, address, PAIR_NONE);
-            }
+            RawAddress address(device.second->GetAddress());
+            SendPairStatusChanged(ADAPTER_BREDR, address, PAIR_NONE);
         }
         break;
     }
@@ -2415,13 +2429,48 @@ bool ClassicAdapter::IsHfpCodSupported(const RawAddress &device)
         HILOGE("remoteDevice is nullptr");
         return false;
     }
-    int cod = remoteDevice->GetDeviceClass();
-    if ((cod & CLASS_OF_DEVICE_MASK) == CLASS_OF_DEVICE_AV_HEADSETS ||
-        (cod & CLASS_OF_DEVICE_MASK) == CLASS_OF_DEVICE_AV_HANDSFREE) {
+    uint32_t cod = (uint32_t)remoteDevice->GetDeviceClass();
+    /// Referenced from Assigned NUmbers,Class of Device format :
+    /// 23-13 bit  Major Service Classes
+    /// 12-8 bit Major Device Class
+    /// 7-2 bit Minor Device Class
+    /// 1-0 bit 0b00
+    /// The 21st bit indicates Audio.
+    const uint32_t audioSerClassMask = 0x200000;
+    if (cod & audioSerClassMask) {
             return true;
     }
     return false;
 }
+
+bool ClassicAdapter::SetHidPnpInfo(const std::string &remoteAddr, int vendorId, int productId, int version)
+{
+    return adapterProperties_.SetHidPnpInfo(remoteAddr, vendorId, productId, version);
+}
+
+bool ClassicAdapter::SetHidDescInfo(
+    const std::string &remoteAddr, int ctryCode, const std::vector<uint8_t> &descData, int descLength)
+{
+    bool ret = adapterProperties_.SetHidDescInfo(remoteAddr, ctryCode, ClassicUtils::ConvertIntToHexString(descData));
+    if (ret) {
+        adapterProperties_.SaveConfigFile();
+    }
+    return ret;
+}
+
+void ClassicAdapter::GetHidPnpInfo(const std::string &remoteAddr, int &vendorId, int &productId, int &version)
+{
+    adapterProperties_.GetHidPnpInfo(remoteAddr, vendorId, productId, version);
+}
+
+void ClassicAdapter::GetHidDescInfo(
+    const std::string &remoteAddr, int &ctryCode, std::vector<uint8_t> &descData, int &descLength)
+{
+    std::string descInfo = "";
+    adapterProperties_.GetHidDescInfo(remoteAddr, ctryCode, descInfo);
+    ClassicUtils::ConvertHexStringToInt(descInfo, descData);
+    descLength = descData.size();
+}
 REGISTER_CLASS_CREATOR(ClassicAdapter);
 }  // namespace bluetooth
 }  // namespace OHOS
\ No newline at end of file
diff --git a/services/bluetooth/service/src/classic/classic_adapter.h b/services/bluetooth/service/src/classic/classic_adapter.h
index 4aea1b1..2a57f35 100644
--- a/services/bluetooth/service/src/classic/classic_adapter.h
+++ b/services/bluetooth/service/src/classic/classic_adapter.h
@@ -403,6 +403,13 @@ public:
     void SetDeviceBatteryLevel(const RawAddress &device, int batteryLevel) const override;
     bool IsHfpCodSupported(const RawAddress &device) override;
 
+    bool SetHidPnpInfo(const std::string &remoteAddr, int vendorId, int productId, int version) override;
+    bool SetHidDescInfo(
+        const std::string &remoteAddr, int ctryCode, const std::vector<uint8_t> &descData, int descLength) override;
+    void GetHidPnpInfo(const std::string &remoteAddr, int &vendorId, int &productId, int &version) override;
+    void GetHidDescInfo(
+        const std::string &remoteAddr, int &ctryCode, std::vector<uint8_t> &descData, int &descLength) override;
+
 private:
     /**
      * @brief Inquiry result callback.
diff --git a/services/bluetooth/service/src/classic/classic_adapter_properties.cpp b/services/bluetooth/service/src/classic/classic_adapter_properties.cpp
index 939006a..eb7dcfe 100644
--- a/services/bluetooth/service/src/classic/classic_adapter_properties.cpp
+++ b/services/bluetooth/service/src/classic/classic_adapter_properties.cpp
@@ -550,5 +550,49 @@ bool ClassicAdapterProperties::SaveSupportUuids(const std::vector<Uuid> &uuids)
 
     return ret;
 }
+
+bool ClassicAdapterProperties::SetHidPnpInfo(const std::string &addr, int vendorId, int productId, int version)
+{
+    bool retVendorId = config_.SetRemoteHidVendorId(addr, vendorId);
+    ClassicUtils::CheckReturnValue("ClassicAdapaterProperties", "SetRemoteHidVendorId", retVendorId);
+
+    bool retProductId = config_.SetRemoteHidProductId(addr, productId);
+    ClassicUtils::CheckReturnValue("ClassicAdapaterProperties", "SetRemoteHidProductId", retProductId);
+
+    bool retVersion = config_.SetRemoteHidVersion(addr, version);
+    ClassicUtils::CheckReturnValue("ClassicAdapaterProperties", "SetRemoteHidVersion", retVersion);
+
+    if (retVendorId && retProductId && retVersion) {
+        return true;
+    }
+    return false;
+}
+
+bool ClassicAdapterProperties::SetHidDescInfo(const std::string &addr, int ctryCode, const std::string &descInfo)
+{
+    bool retCtryCode = config_.SetRemoteHidCtryCode(addr, ctryCode);
+    ClassicUtils::CheckReturnValue("ClassicAdapaterProperties", "SetRemoteHidCtryCode", retCtryCode);
+
+    bool retDescInfo = config_.SetRemoteHidDescInfo(addr, descInfo);
+    ClassicUtils::CheckReturnValue("ClassicAdapaterProperties", "SetRemoteHidProductId", retDescInfo);
+
+    if (retCtryCode && retDescInfo) {
+        return true;
+    }
+    return false;
+}
+
+void ClassicAdapterProperties::GetHidPnpInfo(const std::string &addr, int &vendorId, int &productId, int &version)
+{
+    vendorId = config_.GetRemoteHidVendorId(addr);
+    productId = config_.GetRemoteHidProductId(addr);
+    version = config_.GetRemoteHidVersion(addr);
+}
+
+void ClassicAdapterProperties::GetHidDescInfo(const std::string &addr, int &ctryCode, std::string &descInfo)
+{
+    ctryCode = config_.GetRemoteHidCtryCode(addr);
+    descInfo = config_.GetRemoteHidDescInfo(addr);
+}
 }  // namespace bluetooth
 }  // namespace OHOS
\ No newline at end of file
diff --git a/services/bluetooth/service/src/classic/classic_adapter_properties.h b/services/bluetooth/service/src/classic/classic_adapter_properties.h
index 88c5e96..5d1c95e 100644
--- a/services/bluetooth/service/src/classic/classic_adapter_properties.h
+++ b/services/bluetooth/service/src/classic/classic_adapter_properties.h
@@ -262,6 +262,11 @@ public:
      */
     bool SaveSupportUuids(const std::vector<Uuid> &uuids);
 
+    bool SetHidPnpInfo(const std::string &addr, int vendorId, int productId, int version);
+    bool SetHidDescInfo(const std::string &addr, int ctryCode, const std::string &descInfo);
+    void GetHidPnpInfo(const std::string &addr, int &vendorId, int &productId, int &version);
+    void GetHidDescInfo(const std::string &addr, int &ctryCode, std::string &descInfo);
+
 private:
     /**
      * @brief A constructor used to create a <b>ClassicAdapterProperties</b> instance.
diff --git a/services/bluetooth/service/src/classic/classic_config.cpp b/services/bluetooth/service/src/classic/classic_config.cpp
index 820230c..3b6b293 100644
--- a/services/bluetooth/service/src/classic/classic_config.cpp
+++ b/services/bluetooth/service/src/classic/classic_config.cpp
@@ -374,5 +374,105 @@ std::string ClassicConfig::GetRemoteUuids(const std::string &subSection) const
 
     return uuids;
 }
+
+bool ClassicConfig::SetRemoteHidVendorId(const std::string &subSection, int vendorId) const
+{
+    if (!config_->SetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_VENDOR_ID, vendorId)) {
+        LOG_WARN("[ClassicConfig]::%{public}s failed!", __func__);
+        return false;
+    }
+
+    return true;
+}
+
+int ClassicConfig::GetRemoteHidVendorId(const std::string &subSection) const
+{
+    int vendorId = 0;
+    if (!config_->GetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_VENDOR_ID, vendorId)) {
+        LOG_INFO("[ClassicConfig]::%{public}s failed!", __func__);
+    }
+
+    return vendorId;
+}
+
+bool ClassicConfig::SetRemoteHidProductId(const std::string &subSection, int productId) const
+{
+    if (!config_->SetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_PRODUCT_ID, productId)) {
+        LOG_WARN("[ClassicConfig]::%{public}s failed!", __func__);
+        return false;
+    }
+
+    return true;
+}
+
+int ClassicConfig::GetRemoteHidProductId(const std::string &subSection) const
+{
+    int productId = 0;
+    if (!config_->GetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_PRODUCT_ID, productId)) {
+        LOG_INFO("[ClassicConfig]::%{public}s failed!", __func__);
+    }
+
+    return productId;
+}
+
+bool ClassicConfig::SetRemoteHidVersion(const std::string &subSection, int version) const
+{
+    if (!config_->SetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_VERSION, version)) {
+        LOG_WARN("[ClassicConfig]::%{public}s failed!", __func__);
+        return false;
+    }
+
+    return true;
+}
+
+int ClassicConfig::GetRemoteHidVersion(const std::string &subSection) const
+{
+    int version = 0;
+    if (!config_->GetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_VERSION, version)) {
+        LOG_INFO("[ClassicConfig]::%{public}s failed!", __func__);
+    }
+
+    return version;
+}
+
+bool ClassicConfig::SetRemoteHidCtryCode(const std::string &subSection, int ctryCode) const
+{
+    if (!config_->SetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_CTRY_CODE, ctryCode)) {
+        LOG_WARN("[ClassicConfig]::%{public}s failed!", __func__);
+        return false;
+    }
+
+    return true;
+}
+
+int ClassicConfig::GetRemoteHidCtryCode(const std::string &subSection) const
+{
+    int ctryCode = 0;
+    if (!config_->GetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_CTRY_CODE, ctryCode)) {
+        LOG_INFO("[ClassicConfig]::%{public}s failed!", __func__);
+    }
+
+    return ctryCode;
+}
+
+bool ClassicConfig::SetRemoteHidDescInfo(const std::string &subSection, const std::string &descInfo) const
+{
+    if (!config_->SetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_DESC_INFO, descInfo)) {
+        LOG_WARN("[ClassicConfig]::%{public}s failed!", __func__);
+        return false;
+    }
+
+    return true;
+}
+
+std::string ClassicConfig::GetRemoteHidDescInfo(const std::string &subSection) const
+{
+    std::string descInfo = "";
+    if (!config_->GetValue(SECTION_BREDR_PAIRED_LIST, subSection, PROPERTY_HID_DESC_INFO, descInfo)) {
+        LOG_INFO("[ClassicConfig]::%{public}s failed!", __func__);
+    }
+
+    return descInfo;
+}
 }  // namespace bluetooth
 }  // namespace OHOS
\ No newline at end of file
diff --git a/services/bluetooth/service/src/classic/classic_config.h b/services/bluetooth/service/src/classic/classic_config.h
index a31a918..bca6511 100644
--- a/services/bluetooth/service/src/classic/classic_config.h
+++ b/services/bluetooth/service/src/classic/classic_config.h
@@ -341,6 +341,17 @@ public:
      */
     std::string GetRemoteUuids(const std::string &subSection) const;
 
+    bool SetRemoteHidVendorId(const std::string &subSection, int vendorId) const;
+    int GetRemoteHidVendorId(const std::string &subSection) const;
+    bool SetRemoteHidProductId(const std::string &subSection, int productId) const;
+    int GetRemoteHidProductId(const std::string &subSection) const;
+    bool SetRemoteHidVersion(const std::string &subSection, int version) const;
+    int GetRemoteHidVersion(const std::string &subSection) const;
+    bool SetRemoteHidCtryCode(const std::string &subSection, int ctryCode) const;
+    int GetRemoteHidCtryCode(const std::string &subSection) const;
+    bool SetRemoteHidDescInfo(const std::string &subSection, const std::string &descInfo) const;
+    std::string GetRemoteHidDescInfo(const std::string &subSection) const;
+
 private:
     /**
      * @brief A constructor used to create a <b>ClassicConfig</b> instance.
diff --git a/services/bluetooth/service/src/classic/classic_remote_device.h b/services/bluetooth/service/src/classic/classic_remote_device.h
index ad5e9fa..1c2db5f 100644
--- a/services/bluetooth/service/src/classic/classic_remote_device.h
+++ b/services/bluetooth/service/src/classic/classic_remote_device.h
@@ -391,7 +391,7 @@ private:
     int connectionHandle_ {};
     int pairState_ {};
     int pairConfirmType_ {PAIR_CONFIRM_TYPE_INVALID};
-    int pairConfirmState_ {PAIR_CONFIRM_STATE_INVALID};
+    int pairConfirmState_ {PAIR_CONFIRM_STATE_USER_CONFIRM_REPLY};
     int linkKeyType_ {PAIR_INVALID_LINK_KEY_TYPE};
     int ioCapability_ {};
     int batteryLevel_ {};
diff --git a/services/bluetooth/service/src/common/adapter_device_config.h b/services/bluetooth/service/src/common/adapter_device_config.h
index d2b942b..05aa1b4 100644
--- a/services/bluetooth/service/src/common/adapter_device_config.h
+++ b/services/bluetooth/service/src/common/adapter_device_config.h
@@ -88,6 +88,12 @@ const std::string PROPERTY_GATT_TRANSPORT = "GattTransport";
 const std::string PROPERTY_GATTS_START_HANDLE = "GattsStartHandle";
 const std::string PROPERTY_GATTS_END_HANDLE = "GattsEndHandle";
 
+const std::string PROPERTY_HID_VENDOR_ID = "HidVendorId";
+const std::string PROPERTY_HID_PRODUCT_ID = "HidProductId";
+const std::string PROPERTY_HID_VERSION = "HidVersion";
+const std::string PROPERTY_HID_CTRY_CODE = "HidCtryCode";
+const std::string PROPERTY_HID_DESC_INFO = "HidDescInfo";
+
 /**
  * @brief BREDR/BLE config.
  */
diff --git a/services/bluetooth/service/src/gavdp/a2dp_codec/include/a2dp_codec_constant.h b/services/bluetooth/service/src/gavdp/a2dp_codec/include/a2dp_codec_constant.h
index 508abb5..d26cf72 100644
--- a/services/bluetooth/service/src/gavdp/a2dp_codec/include/a2dp_codec_constant.h
+++ b/services/bluetooth/service/src/gavdp/a2dp_codec/include/a2dp_codec_constant.h
@@ -200,7 +200,7 @@ static const A2dpSBCCapability A2DP_SBC_SINK_CAPS = {
 /* Default SBC codec configuration */
 const A2dpSBCCapability A2DP_SBC_DEFAULT_CONFIG = {
     A2DP_SBC_SAMPLE_RATE_44100,   /* sampleFreq */
-    A2DP_SBC_CHANNEL_MODE_MONO, /* channelMode */
+    A2DP_SBC_CHANNEL_MODE_STEREO, /* channelMode */
     A2DP_SBC_BLOCKS_16,           /* blockLen */
     A2DP_SBC_SUBBAND_8,           /* numSubbands */
     A2DP_SBC_ALLOC_MODE_L,        /* allocatedMethod */
diff --git a/services/bluetooth/service/src/gavdp/a2dp_def.h b/services/bluetooth/service/src/gavdp/a2dp_def.h
index 0206850..ebbf9ea 100644
--- a/services/bluetooth/service/src/gavdp/a2dp_def.h
+++ b/services/bluetooth/service/src/gavdp/a2dp_def.h
@@ -87,7 +87,7 @@ struct CodecInfo {
     uint8_t codecInfo[A2DP_CODEC_SIZE];  // Codec codecInfo
 };
 
-enum ServiceStatus {
+enum ServiceState {
     STREAM_CONNECTING,
     STREAM_CONNECT,
     STREAM_DISCONNECTING,
diff --git a/services/bluetooth/service/src/gavdp/a2dp_profile.cpp b/services/bluetooth/service/src/gavdp/a2dp_profile.cpp
index e52398e..d55b957 100644
--- a/services/bluetooth/service/src/gavdp/a2dp_profile.cpp
+++ b/services/bluetooth/service/src/gavdp/a2dp_profile.cpp
@@ -201,16 +201,13 @@ void A2dpProfile::ConnectStateChangedNotify(const BtAddr &addr, const int state,
     switch (state) {
         case STREAM_CONNECT_FAILED:
         case STREAM_DISCONNECT:
-            ResetDelayValue(addr);
             DeletePeer(addr);
             if (IsActiveDevice(addr)) {
+                ResetDelayValue(addr);
                 ClearActiveDevice();
+                QueueFlush(packetQueue_, CleanPacketData);
+                buffer_->Reset();
             }
-            QueueFlush(packetQueue_, CleanPacketData);
-            buffer_->Reset();
-            break;
-        case STREAM_CONNECT:
-            SetActivePeer(addr);
             break;
         default:
             break;
@@ -228,7 +225,9 @@ void A2dpProfile::AudioStateChangedNotify(const BtAddr &addr, const int state, v
     if (state == A2DP_IS_PLAYING) {
         buffer_->SetValid(true);
     } else {
-        buffer_->SetValid(false);
+        if (IsActiveDevice(addr)) {
+            buffer_->SetValid(false);
+        }
     }
     if (a2dpSvcCBack_ != nullptr) {
         a2dpSvcCBack_->OnAudioStateChanged(addr, state, context);
@@ -538,16 +537,19 @@ void A2dpProfile::Disable()
     }
     SetProfileEnable(false);
 
-    for (const auto &it : peers_) {
-        peer = it.second;
-        HILOGI("[A2dpProfile] matched peers_addr(%{public}s) [role%u]\n", GetEncryptAddr(it.first).c_str(), role);
-        if (peer != nullptr && it.first.c_str() != nullptr) {
+    std::map<std::string, A2dpProfilePeer *>::iterator it;
+    for (it = peers_.begin(); it != peers_.end();) {
+        peer = it->second;
+        if (peer != nullptr && it->first.c_str() != nullptr) {
+            HILOGI("[A2dpProfile] matched peers_addr(%{public}s) [role%u]\n", GetEncryptAddr(it->first).c_str(), role);
             data.a2dpMsg.connectInfo.addr = peer->GetPeerAddress();
             data.role = role;
             msg.arg2_ = &data;
+            it++;
             peer->GetStateMachine()->ProcessMessage(msg);
             peer->SetCurrentCmd(EVT_DISCONNECT_REQ);
-            break;
+        } else {
+            it++;
         }
     }
     if (GetGapRegisterInfo()) {
@@ -604,7 +606,6 @@ int A2dpProfile::Connect(const BtAddr &device)
     } else {
         a2dpInstance = A2dpSnkProfile::GetInstance();
     }
-    FindOrCreatePeer(device, role);
     if (GetSDPInstance().FindSnkService(device, a2dpInstance, A2dpProfilePeer::SDPServiceCallback) != BT_SUCCESS) {
         LOG_WARN("[A2dpProfile]%{public}s SDP_ServiceSearch Error\n", __func__);
     }
diff --git a/services/bluetooth/service/src/gavdp/a2dp_service.cpp b/services/bluetooth/service/src/gavdp/a2dp_service.cpp
index a75368c..a86611f 100644
--- a/services/bluetooth/service/src/gavdp/a2dp_service.cpp
+++ b/services/bluetooth/service/src/gavdp/a2dp_service.cpp
@@ -24,12 +24,17 @@
 #include "profile_service_manager.h"
 #include "securec.h"
 #include "idevmgr_hdi.h"
+#include "avrcp_tg/avrcp_tg_service.h"
 
 constexpr const char *AUDIO_BLUETOOTH_SERVICE_NAME = "audio_bluetooth_hdi_service";
 
 namespace OHOS {
 namespace bluetooth {
 std::recursive_mutex g_a2dpServiceMutex {};
+struct HDIServiceManager *g_hdiServiceManager;
+struct ServiceStatusListener *g_listener;
+BtAddr g_btAddr;
+const uint16_t AUDIO_CLASS = 0x1 << 5;
 ObserverProfile::ObserverProfile(uint8_t role)
 {
     role_ = role;
@@ -70,19 +75,65 @@ void ObserverProfile::OnConnectStateChanged(const BtAddr &addr, const int state,
         service->ConnectManager().DeleteDevice(btAddr);
     } else if (connectState == static_cast<int>(BTConnectState::CONNECTED)) {
         LOG_INFO("[ObserverProfile] %{public}s Add the active device\n", __func__);
-        service->UpdateActiveDevice(btAddr);
     }
 
-    if ((connectState == static_cast<int>(BTConnectState::CONNECTED)) ||
-        (connectState == static_cast<int>(BTConnectState::DISCONNECTED))) {
+    if (connectState == static_cast<int>(BTConnectState::DISCONNECTED)) {
         service->ProcessConnectFrameworkCallback(connectState, btAddr);
         ProcessA2dpHdfLoad(connectState);
+    } else if (connectState == static_cast<int>(BTConnectState::CONNECTED)) {
+        memcpy_s(&g_btAddr, sizeof(BtAddr), &addr, sizeof(BtAddr));
+        ProcessA2dpHdfLoad(connectState);
     }
 
     service->CheckDisable();
     return;
 }
 
+static void OnServiceStatusReceived(struct ServiceStatusListener *listener, struct ServiceStatus *serviceStatus)
+{
+    CHECK_AND_RETURN_LOG(serviceStatus != nullptr, "Invalid ServiceStatus");
+    std::string info = serviceStatus->info;
+    LOG_INFO("OnServiceStatusReceived: [service name:%{public}s] [status:%{public}d] [info:%{public}s]",
+        serviceStatus->serviceName, serviceStatus->status, info.c_str());
+    if ((strcmp(serviceStatus->serviceName, AUDIO_BLUETOOTH_SERVICE_NAME) == 0) &&
+        (serviceStatus->status == SERVIE_STATUS_START)) {
+        A2dpService *service = GetServiceInstance(A2DP_ROLE_SOURCE);
+        if (service == nullptr) {
+            LOG_ERROR("service is nullptr");
+            return;
+        }
+        RawAddress btAddr = bluetooth::RawAddress::ConvertToString(g_btAddr.addr);
+        service->ProcessConnectFrameworkCallback(static_cast<int>(BTConnectState::CONNECTED),
+            btAddr);
+        if ((g_hdiServiceManager == nullptr) || (g_listener == nullptr)) {
+            LOG_ERROR("g_hdiServiceManager or g_listener is nullptr");
+            return;
+        }
+        int32_t status = g_hdiServiceManager->UnregisterServiceStatusListener(g_hdiServiceManager, g_listener);
+        CHECK_AND_RETURN_LOG(status == HDF_SUCCESS,
+            "[DevicesStatusListener]:UnRegister service status listener failed");
+        g_hdiServiceManager = nullptr;
+        g_listener = nullptr;
+    }
+}
+
+void RegisterDeviceStatusListener()
+{
+    g_hdiServiceManager = HDIServiceManagerGet();
+    if (g_hdiServiceManager == nullptr) {
+        LOG_ERROR("HDIServiceManager Get error \n");
+        return;
+    }
+    g_listener = HdiServiceStatusListenerNewInstance();
+    if (g_listener == nullptr) {
+        LOG_ERROR("HdiServiceStatusListenerNewInstance error \n");
+        return;
+    }
+    g_listener->callback = OnServiceStatusReceived;
+    int32_t status = g_hdiServiceManager->RegisterServiceStatusListener(g_hdiServiceManager, g_listener, AUDIO_CLASS);
+    CHECK_AND_RETURN_LOG(status == HDF_SUCCESS, "RegisterServiceStatusListener failed");
+}
+
 void ObserverProfile::ProcessA2dpHdfLoad(const int state) const
 {
     LOG_INFO("[ObserverProfile] %{public}s state:%{public}d \n", __func__, state);
@@ -94,11 +145,18 @@ void ObserverProfile::ProcessA2dpHdfLoad(const int state) const
     }
     std::vector<RawAddress> devices = service->GetDevicesByStates(states);
 
-    if (state == static_cast<int>(BTConnectState::CONNECTED) && devices.size() == 1) {
-        auto devmgr = OHOS::HDI::DeviceManager::V1_0::IDeviceManager::Get();
-        if (devmgr != nullptr) {
-            LOG_INFO("[ObserverProfile] %{public}s, loadDevice of a2dp HDF", __func__);
-            devmgr->LoadDevice(AUDIO_BLUETOOTH_SERVICE_NAME);
+    if (state == static_cast<int>(BTConnectState::CONNECTED)) {
+        if (devices.size() == 1) {
+            auto devmgr = OHOS::HDI::DeviceManager::V1_0::IDeviceManager::Get();
+            if (devmgr != nullptr) {
+                LOG_INFO("[ObserverProfile] %{public}s, loadDevice of a2dp HDF", __func__);
+                RegisterDeviceStatusListener();
+                devmgr->LoadDevice(AUDIO_BLUETOOTH_SERVICE_NAME);
+            }
+        } else {
+            RawAddress btAddr = bluetooth::RawAddress::ConvertToString(g_btAddr.addr);
+            service->ProcessConnectFrameworkCallback(static_cast<int>(BTConnectState::CONNECTED),
+                btAddr);
         }
     }
     if (state == static_cast<int>(BTConnectState::DISCONNECTED) && devices.size() == 0) {
@@ -355,6 +413,12 @@ int A2dpService::Disconnect(const RawAddress &device)
         }
     }
 
+    auto servManager = IProfileManager::GetInstance();
+    auto service = static_cast<AvrcpTgService *>(servManager->GetProfileService(PROFILE_NAME_AVRCP_TG));
+    if (service != nullptr) {
+        service->Disconnect(device);
+    }
+
     return ret;
 }
 
@@ -493,22 +557,20 @@ void A2dpService::DisableService()
         }
     }
 
-    if (GetConnectState() != PROFILE_STATE_DISCONNECTED) {
-        return;
-    }
-
-    for (auto it = a2dpDevices_.begin(); it != a2dpDevices_.end(); it++) {
-        if (it->second != nullptr) {
-            delete it->second;
-            it->second = nullptr;
+    if ((GetConnectState() == PROFILE_STATE_DISCONNECTED)||(GetConnectState() == (PROFILE_STATE_CONNECTING|PROFILE_STATE_DISCONNECTED))) {
+        for (auto it = a2dpDevices_.begin(); it != a2dpDevices_.end(); it++) {
+            if (it->second != nullptr) {
+                delete it->second;
+                it->second = nullptr;
+            }
         }
-    }
 
-    a2dpDevices_.clear();
-    instance->DeregisterObserver(&profileObserver_);
-    GetContext()->OnDisable(name_, ret);
-    isDoDisable = false;
-    instance->SetDisalbeTag(false);
+        a2dpDevices_.clear();
+        instance->DeregisterObserver(&profileObserver_);
+        GetContext()->OnDisable(name_, ret);
+        isDoDisable = false;
+        instance->SetDisalbeTag(false);
+    }
 }
 
 std::vector<RawAddress> A2dpService::GetDevicesByStates(std::vector<int>& states) const
@@ -596,16 +658,14 @@ int A2dpService::SetActiveSinkDevice(const RawAddress &device)
     }
 
     auto curDevice = a2dpDevices_.find(activeDevice_.GetAddress().c_str());
-    if (strcmp(device.GetAddress().c_str(), activeDevice_.GetAddress().c_str()) == 0) {
-        LOG_ERROR("[A2dpService]The device is already active");
-        pflA2dp->Start(curDevice->second->GetHandle());
-    } else {
+    if (strcmp(device.GetAddress().c_str(), activeDevice_.GetAddress().c_str()) != 0) {
         if (curDevice != a2dpDevices_.end() && curDevice->second != nullptr) {
-            if (pflA2dp->Stop(curDevice->second->GetHandle(), true)) {
-                pflA2dp->Start(iter->second->GetHandle());
+            A2dpProfilePeer *peer = nullptr;
+            peer = pflA2dp->FindPeerByAddress(curDevice->second->GetDevice());
+            if (peer != nullptr &&
+                strcmp(A2DP_PROFILE_STREAMING.c_str(), peer->GetStateMachine()->GetStateName().c_str()) == 0) {
+                pflA2dp->Stop(curDevice->second->GetHandle(), true);
             }
-        } else {
-            pflA2dp->Start(iter->second->GetHandle());
         }
         pflA2dp->SetActivePeer(btAddr);
         UpdateActiveDevice(rawAddr);
diff --git a/services/bluetooth/service/src/gavdp/a2dp_service.h b/services/bluetooth/service/src/gavdp/a2dp_service.h
index 8001389..3a06eb5 100644
--- a/services/bluetooth/service/src/gavdp/a2dp_service.h
+++ b/services/bluetooth/service/src/gavdp/a2dp_service.h
@@ -25,6 +25,8 @@
 #ifndef A2DP_SERVICE_H
 #define A2DP_SERVICE_H
 
+#include <servmgr_hdi.h>
+
 #include <cstdint>
 #include <list>
 #include <map>
diff --git a/services/bluetooth/service/src/gavdp/a2dp_state_machine.cpp b/services/bluetooth/service/src/gavdp/a2dp_state_machine.cpp
index 91c5796..0fe7364 100644
--- a/services/bluetooth/service/src/gavdp/a2dp_state_machine.cpp
+++ b/services/bluetooth/service/src/gavdp/a2dp_state_machine.cpp
@@ -25,14 +25,6 @@
 namespace OHOS {
 namespace bluetooth {
 std::recursive_mutex g_stateMutex {};
-void A2dpStateIdle::Entry()
-{
-    A2dpCodecThread *codecThread = A2dpCodecThread::GetInstance();
-    if (codecThread->GetInitStatus()) {
-        codecThread->StopA2dpCodecThread();
-        delete codecThread;
-    }
-}
 
 bool A2dpStateIdle::Dispatch(const utility::Message &msg)
 {
diff --git a/services/bluetooth/service/src/gavdp/a2dp_state_machine.h b/services/bluetooth/service/src/gavdp/a2dp_state_machine.h
index e5d9297..58addd2 100644
--- a/services/bluetooth/service/src/gavdp/a2dp_state_machine.h
+++ b/services/bluetooth/service/src/gavdp/a2dp_state_machine.h
@@ -58,7 +58,8 @@ public:
      * @brief Operation should be executed when Entry the state.
      * @since 6.0
      */
-    void Entry();
+    void Entry()
+    {}
 
     /**
      * @brief Operation should be executed when Exit the state.
diff --git a/services/bluetooth/service/src/hfp_ag/hfp_ag_defines.h b/services/bluetooth/service/src/hfp_ag/hfp_ag_defines.h
index 4ebf73c..5518308 100644
--- a/services/bluetooth/service/src/hfp_ag/hfp_ag_defines.h
+++ b/services/bluetooth/service/src/hfp_ag/hfp_ag_defines.h
@@ -115,8 +115,7 @@ static constexpr uint32_t HFP_AG_FEATURES_DEFAULT = HFP_AG_FEATURES_THREE_WAY |
                                                     HFP_AG_FEATURES_REJECT_CALL |
                                                     HFP_AG_FEATURES_ENHANCED_CALL_STATUS |
                                                     HFP_AG_FEATURES_EXTEND_ERROR_CODE |
-                                                    HFP_AG_FEATURES_HF_INDICATORS |
-                                                    HFP_AG_FEATURES_PASS_UNKNOWN_AT;
+                                                    HFP_AG_FEATURES_HF_INDICATORS;
 
 // Specific SDP AG features
 static constexpr uint32_t HFP_AG_FEATURES_SDP_SPEC = HFP_AG_FEATURES_THREE_WAY |
diff --git a/services/bluetooth/service/src/hfp_ag/hfp_ag_profile.cpp b/services/bluetooth/service/src/hfp_ag/hfp_ag_profile.cpp
index 6289f4e..26f85a1 100644
--- a/services/bluetooth/service/src/hfp_ag/hfp_ag_profile.cpp
+++ b/services/bluetooth/service/src/hfp_ag/hfp_ag_profile.cpp
@@ -749,13 +749,6 @@ int HfpAgProfile::ProcessCurrentCallStateIncominging(
     dataConn_.clipType_ = type;
     SendRingAndClip();
     LOG_INFO("inBandRingTone_ %{public}d", dataConn_.inBandRingTone_);
-    auto isAudioConnected = HfpAgAudioConnection::IsAudioConnected(address_);
-    if ((preNumActiveCalls_ == 0) && (preNumHeldCalls_ == 0) &&
-        (dataConn_.inBandRingTone_ == HFP_AG_INBAND_RING_ENABLE) &&
-        (isAudioConnected == false)) {
-        HfpAgProfileEventSender::GetInstance().UpdateScoConnectState(address_, HFP_AG_CONNECT_AUDIO_EVT);
-        scoPostProcess_ = true;
-    }
 
     return HFP_AG_SUCCESS;
 }
diff --git a/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.cpp b/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.cpp
index fb897f4..151ced4 100644
--- a/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.cpp
+++ b/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.cpp
@@ -47,14 +47,16 @@ void HfpAgSdpClient::SdpCallback(const BtAddr *addr, const SdpService *serviceAr
         CopySdpServiceArray(address, serviceAry, serviceNum);
         msgWhat = HFP_AG_SDP_DISCOVERY_RESULT_SUCCESS;
         hfProfileState_ = HFP_AG_HF_FOUND;
-    }
-    int hspState = 1;
-    AdapterConfig::GetInstance()->GetValue(HSP_AG_STATE_SECTION_NAME, HSP_AG_STATE_PROPERY_NAME, hspState);
-    if (hspState == HSP_AG_STATE_BOTH) {
-        HfpAgSdpClient *sdpClient = static_cast<HfpAgSdpClient *>(context);
-        HfpAgService::GetService()->GetDispatcher()->PostTask(
-            std::bind(&HfpAgSdpClient::DoHspHsDiscovery, sdpClient, address));
-        return;
+    } else {
+        int hspState = 1;
+        AdapterConfig::GetInstance()->GetValue(HSP_AG_STATE_SECTION_NAME, HSP_AG_STATE_PROPERY_NAME, hspState);
+        if (hspState == HSP_AG_STATE_BOTH) {
+            HfpAgSdpClient *sdpClient = static_cast<HfpAgSdpClient *>(context);
+            HfpAgService::GetService()->GetDispatcher()->PostTask(
+                std::bind(&HfpAgSdpClient::DoHspHsDiscovery, sdpClient, address));
+            LOG_INFO("[HFP AG] start hsp hs dicovery");
+            return;
+        }
     }
     HfpAgProfileEventSender::GetInstance().ProcessSdpDiscoveryResult(address, msgWhat);
 }
@@ -62,11 +64,41 @@ void HfpAgSdpClient::SdpCallback(const BtAddr *addr, const SdpService *serviceAr
 int HfpAgSdpClient::DoDiscovery(const std::string &remoteAddr, int role)
 {
     hfProfileState_ = -1;
+    int ret = 0;
+
     AdapterConfig::GetInstance()->GetValue(HSP_AG_STATE_SECTION_NAME, HSP_AG_STATE_PROPERY_NAME, hspState_);
     if (hspState_ == HSP_AG_STATE_HSP) {
-        LOG_INFO("[HFP AG] start hsp hs dicovery");
-        return DoHspHsDiscovery(remoteAddr);
+        ret = DoHspHsDiscovery(remoteAddr);
+        LOG_INFO("[HFP AG] start hsp hs dicovery :%{public}d", ret);
+    } else {
+        ret = DoHfpDiscovery(remoteAddr, role);
+        LOG_INFO("[HFP AG] start hfp dicovery :%{public}d", ret);
     }
+    return ret;
+}
+
+void HfpAgSdpClient::SdpHspHsCallback(const BtAddr *addr, const SdpService *serviceAry,
+    uint16_t serviceNum, void *context)
+{
+    int msgWhat = HFP_AG_SDP_DISCOVERY_RESULT_FAIL;
+    std::string address = RawAddress::ConvertToString(addr->addr).GetAddress();
+    if (serviceNum > 0) {
+        CopySdpServiceArray(address, serviceAry, serviceNum);
+        msgWhat = HFP_AG_SDP_DISCOVERY_RESULT_SUCCESS;
+        if (hfProfileState_ == HFP_AG_HF_FOUND) {
+            hfProfileState_ = HFP_AG_HF_HS_FOUND;
+        } else {
+            hfProfileState_ = HFP_AG_HS_FOUND;
+        }
+    }
+    if (hfProfileState_ != -1) {
+        msgWhat = HFP_AG_SDP_DISCOVERY_RESULT_SUCCESS;
+    }
+    HfpAgProfileEventSender::GetInstance().ProcessSdpDiscoveryResult(address, msgWhat);
+}
+
+int HfpAgSdpClient::DoHfpDiscovery(const std::string &remoteAddr, int role)
+{
     BtAddr address;
     address.type = BT_PUBLIC_DEVICE_ADDRESS;
     RawAddress rawAddr(remoteAddr);
@@ -107,26 +139,6 @@ int HfpAgSdpClient::DoDiscovery(const std::string &remoteAddr, int role)
     return ret;
 }
 
-void HfpAgSdpClient::SdpHspHsCallback(const BtAddr *addr, const SdpService *serviceAry,
-    uint16_t serviceNum, void *context)
-{
-    int msgWhat = HFP_AG_SDP_DISCOVERY_RESULT_FAIL;
-    std::string address = RawAddress::ConvertToString(addr->addr).GetAddress();
-    if (serviceNum > 0) {
-        CopySdpServiceArray(address, serviceAry, serviceNum);
-        msgWhat = HFP_AG_SDP_DISCOVERY_RESULT_SUCCESS;
-        if (hfProfileState_ == HFP_AG_HF_FOUND) {
-            hfProfileState_ = HFP_AG_HF_HS_FOUND;
-        } else {
-            hfProfileState_ = HFP_AG_HS_FOUND;
-        }
-    }
-    if (hfProfileState_ != -1) {
-        msgWhat = HFP_AG_SDP_DISCOVERY_RESULT_SUCCESS;
-        HfpAgProfileEventSender::GetInstance().ProcessSdpDiscoveryResult(address, msgWhat);
-    }
-}
-
 int HfpAgSdpClient::DoHspHsDiscovery(const std::string &remoteAddr)
 {
     BtAddr address;
@@ -176,6 +188,11 @@ bool HfpAgSdpClient::FindAttributes(const std::string &remoteAddr, int role)
         }
     }
 
+    if (!FindClassId(it->second.services[num].classIds)) {
+        LOG_INFO("[HFP AG]%{public}s():remote don`t support hfp hf or hsp hs.", __FUNCTION__);
+        return false;
+    }
+
     if (!FindProfileVersion(it->second.services[num].profileDescriptors, info.remoteVersion)) {
         info.remoteVersion = HFP_AG_HFP_VERSION_1_1;
         LOG_INFO("[HFP AG]%{public}s():Not found peer HFP version, using default version[1.1]", __FUNCTION__);
@@ -209,6 +226,10 @@ void HfpAgSdpClient::CopySdpServiceArray(
     HfpAgRemoteSdpServiceArray array;
     for (uint16_t n = 0; n < serviceNum; n++) {
         HfpAgRemoteSdpService service;
+        for (uint16_t i = 0; i < serviceAry[n].classIdNumber; i++) {
+            BtUuid classId = serviceAry[n].classId[i];
+            service.classIds.push_back(classId);
+        }
         for (uint16_t i = 0; i < serviceAry[n].descriptorNumber; i++) {
             SdpProtocolDescriptor descriptor = serviceAry[n].descriptor[i];
             service.descriptors.push_back(descriptor);
@@ -322,5 +343,17 @@ bool HfpAgSdpClient::FindProfileFeatures(const std::vector<HfpAgSdpAttribute> &a
     }
     return false;
 }
+
+bool HfpAgSdpClient::FindClassId(const std::vector<BtUuid> &classIds)
+{
+    uint16_t num = 0;
+    while (num < classIds.size()) {
+        if ((classIds[num].uuid16 == HFP_AG_UUID_SERVCLASS_HFP_HF) || (classIds[num].uuid16 == HSP_HS_UUID_SERVCLASS)) {
+            return true;
+        }
+        num++;
+    }
+    return false;
+}
 }  // namespace bluetooth
 }  // namespace OHOS
\ No newline at end of file
diff --git a/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.h b/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.h
index bbefab3..528ae71 100644
--- a/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.h
+++ b/services/bluetooth/service/src/hfp_ag/hfp_ag_sdp_client.h
@@ -35,6 +35,7 @@ typedef struct {
 } HfpAgSdpAttribute;
 
 typedef struct {
+    std::vector<BtUuid> classIds {};                          // HF class id
     std::vector<SdpProtocolDescriptor> descriptors {};        // HF protocol descriptor
     std::vector<SdpProfileDescriptor> profileDescriptors {};  // HF profile descriptor
     std::vector<HfpAgSdpAttribute> attributes {};             // HF attribute descriptor
@@ -89,6 +90,15 @@ public:
      */
     static void SdpHspHsCallback(const BtAddr *addr, const SdpService *serviceAry, uint16_t serviceNum, void *context);
 
+    /**
+     * @brief Start a service discovery job for HFP.
+     *
+     * @param remoteAddr Remote device address.
+     * @param role Role in connection.
+     * @return Returns the error code of the discovery result.
+     */
+    int DoHfpDiscovery(const std::string &remoteAddr, int role);
+
     /**
      * @brief Start a service discovery job for HSP HS.
      *
@@ -167,6 +177,14 @@ private:
      */
     static bool FindProfileFeatures(const std::vector<HfpAgSdpAttribute> &attributes, uint16_t &features);
 
+    /**
+     * @brief Find out remote HF class id.
+     *
+     * @param classIds Service class id list.
+     * @return Returns <b>true</b> if the operation is successful; returns <b>false</b> if the operation fails.
+     */
+    static bool FindClassId(const std::vector<BtUuid> &classIds);
+
     inline static constexpr uint16_t HFP_AG_CLIENT_CLASSID_NUM = 1;
     inline static constexpr uint16_t HFP_AG_CLIENT_INITIATOR_ATTR_NUM = 4;
     inline static constexpr uint16_t HFP_AG_CLIENT_ACCEPTOR_ATTR_NUM = 3;
diff --git a/services/bluetooth/service/src/hid_host/hid_host_sdp_client.cpp b/services/bluetooth/service/src/hid_host/hid_host_sdp_client.cpp
index 65bbfbc..6b4b40e 100644
--- a/services/bluetooth/service/src/hid_host/hid_host_sdp_client.cpp
+++ b/services/bluetooth/service/src/hid_host/hid_host_sdp_client.cpp
@@ -17,12 +17,14 @@
 
 #include "hid_host_service.h"
 #include "hid_host_sdp_client.h"
+#include "interface_adapter_manager.h"
 
 namespace OHOS {
 namespace bluetooth {
 HidHostSdpClient::HidHostSdpClient(std::string address)
 {
     currentAddr_ = address;
+    GetConfigHidSdpInfo();
 }
 
 HidHostSdpClient::~HidHostSdpClient()
@@ -79,6 +81,7 @@ void HidHostSdpClient::SdpCallback_(const BtAddr *addr, const SdpService *servic
         result = HID_HOST_SDP_SUCCESS;
         isSdpDone_ = true;
         printHidSdpInfo();
+        SaveHidSdpInfo();
     }
     SendSdpComplete(result);
 }
@@ -172,6 +175,57 @@ void HidHostSdpClient::printHidSdpInfo()
         hidInf_.serviceName.c_str(), hidInf_.serviceDescription.c_str(), hidInf_.providerName.c_str());
 }
 
+void HidHostSdpClient::SaveHidSdpInfo()
+{
+    LOG_DEBUG("[HIDH SDP]%{public}s() enter!", __FUNCTION__);
+    auto classicAdapter = IAdapterManager::GetInstance()->GetClassicAdapterInterface();
+    if (classicAdapter) {
+        bool ret = classicAdapter->SetHidPnpInfo(currentAddr_, pnpInf_.vendorId, pnpInf_.productId, pnpInf_.version);
+        if (!ret) {
+            LOG_ERROR("[HIDH SDP]%{public}s() SetHidPnpInfo is error!", __FUNCTION__);
+        }
+
+        std::vector<uint8_t> descData = std::vector<uint8_t>(
+            hidInf_.descInfo.get(), hidInf_.descInfo.get() + hidInf_.descLength);
+        ret = classicAdapter->SetHidDescInfo(
+            currentAddr_, hidInf_.ctryCode, descData, hidInf_.descLength);
+        if (!ret) {
+            LOG_ERROR("[HIDH SDP]%{public}s() SetHidDescInfo is error!", __FUNCTION__);
+        }
+    }
+}
+
+void HidHostSdpClient::GetConfigHidSdpInfo()
+{
+    auto classicAdapter = IAdapterManager::GetInstance()->GetClassicAdapterInterface();
+    int vendorId = 0;
+    int productId = 0;
+    int version = 0;
+    int ctryCode = 0;
+    int descLength = 0;
+    std::vector<uint8_t> descData;
+    if (classicAdapter) {
+        classicAdapter->GetHidPnpInfo(currentAddr_, vendorId, productId, version);
+
+        classicAdapter->GetHidDescInfo(currentAddr_, ctryCode, descData, descLength);
+        if (!descData.empty() && descLength > 0) {
+            hidInf_.descInfo = std::make_unique<uint8_t[]>(descLength);
+            if (memcpy_s(hidInf_.descInfo.get(), descLength, &descData[0], descLength) != EOK) {
+                LOG_ERROR("[HIDH SDP]%{public}s() memcpy error", __FUNCTION__);
+                return;
+            }
+
+            pnpInf_.vendorId = vendorId;
+            pnpInf_.productId = productId;
+            pnpInf_.version = version;
+            hidInf_.ctryCode = ctryCode;
+            hidInf_.descLength = descLength;
+            isSdpDone_ = true;
+        }
+    }
+    LOG_DEBUG("[HIDH SDP]%{public}s() isSdpDone_:%{public}d end !", __FUNCTION__, isSdpDone_);
+}
+
 void HidHostSdpClient::SdpPnpCallback(const BtAddr *addr, const SdpService *serviceAry,
     uint16_t serviceNum, void *context)
 {
diff --git a/services/bluetooth/service/src/hid_host/hid_host_sdp_client.h b/services/bluetooth/service/src/hid_host/hid_host_sdp_client.h
index c3ab035..880570f 100644
--- a/services/bluetooth/service/src/hid_host/hid_host_sdp_client.h
+++ b/services/bluetooth/service/src/hid_host/hid_host_sdp_client.h
@@ -91,6 +91,8 @@ private:
     bool ParseHidDescInfo(const SdpService *serviceAry);
     uint8_t CheckAttributeValueLengthAvalid(SdpSequenceAttribute attribute);
     void printHidSdpInfo();
+    void SaveHidSdpInfo();
+    void GetConfigHidSdpInfo();
     // Current remote device address
     std::string currentAddr_ {""};
 
diff --git a/services/bluetooth/service/src/hid_host/hid_host_service.cpp b/services/bluetooth/service/src/hid_host/hid_host_service.cpp
index 54a4121..cf8ddcf 100644
--- a/services/bluetooth/service/src/hid_host/hid_host_service.cpp
+++ b/services/bluetooth/service/src/hid_host/hid_host_service.cpp
@@ -113,7 +113,7 @@ void HidHostService::ShutDown()
     isShuttingDown_ = true;
     bool isDisconnected = false;
     for (auto it = stateMachines_.begin(); it != stateMachines_.end(); ++it) {
-        if ((it->second != nullptr) && (it->second->GetDeviceStateInt() > HID_HOST_STATE_DISCONNECTED)) {
+        if ((it->second != nullptr) && (it->second->GetDeviceStateInt() > HID_HOST_STATE_CONNECTING)) {
             Disconnect(RawAddress(it->first));
             isDisconnected = true;
         }
@@ -129,7 +129,7 @@ void HidHostService::ShutDownDone(bool isAllDisconnected)
     LOG_DEBUG("[HIDH Service]%{public}s():==========<start>==========", __FUNCTION__);
     if (!isAllDisconnected) {
         for (auto it = stateMachines_.begin(); it != stateMachines_.end(); ++it) {
-            if ((it->second != nullptr) && (it->second->GetDeviceStateInt() > HID_HOST_STATE_DISCONNECTED)) {
+            if ((it->second != nullptr) && (it->second->GetDeviceStateInt() > HID_HOST_STATE_CONNECTING)) {
                 return;
             }
         }
